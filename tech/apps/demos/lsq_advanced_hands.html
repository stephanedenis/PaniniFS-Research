<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LSQ - Mod√®les de Mains Articul√©es Professionnels</title>
    <style>
        body {
            margin: 0;
            background: #0a0a0a;
            color: #ffffff;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ff88;
            backdrop-filter: blur(10px);
            max-width: 350px;
        }
        
        .title {
            color: #00ff88;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .section {
            margin-bottom: 15px;
        }
        
        .section-title {
            color: #88ffaa;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        
        button {
            background: linear-gradient(145deg, #1a4a3a, #0d2d1d);
            color: #ffffff;
            border: 1px solid #00ff88;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background: linear-gradient(145deg, #2a6a4a, #1d4d2d);
            border-color: #44ff99;
            transform: translateY(-1px);
        }
        
        .model-info {
            background: rgba(0, 100, 50, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .loading {
            color: #ffaa00;
            font-style: italic;
        }
        
        .success {
            color: #00ff88;
            font-weight: bold;
        }
        
        .error {
            color: #ff4444;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="ui">
        <div class="title">üñêÔ∏è LSQ - Mains Articul√©es</div>
        
        <div class="section">
            <div class="section-title">Mod√®les de Mains WebXR</div>
            <button onclick="loadHandModel('left-white')">Main Gauche Blanche</button>
            <button onclick="loadHandModel('right-white')">Main Droite Blanche</button>
            <button onclick="loadHandModel('left-black')">Main Gauche Noire</button>
            <button onclick="loadHandModel('right-black')">Main Droite Noire</button>
            <button onclick="loadHandModel('skeleton-left')">Squelette Gauche</button>
            <button onclick="loadHandModel('skeleton-right')">Squelette Droit</button>
        </div>
        
        <div class="section">
            <div class="section-title">Gestes LSQ</div>
            <button onclick="performGesture('bonjour')">Bonjour</button>
            <button onclick="performGesture('merci')">Merci</button>
            <button onclick="performGesture('oui')">Oui</button>
            <button onclick="performGesture('non')">Non</button>
            <button onclick="performGesture('maison')">Maison</button>
            <button onclick="performGesture('famille')">Famille</button>
        </div>
        
        <div class="section">
            <div class="section-title">Alphabet LSQ</div>
            <button onclick="performLetter('A')">A</button>
            <button onclick="performLetter('B')">B</button>
            <button onclick="performLetter('C')">C</button>
            <button onclick="performLetter('D')">D</button>
            <button onclick="performLetter('E')">E</button>
            <button onclick="performLetter('F')">F</button>
        </div>
        
        <div class="section">
            <div class="section-title">Animation & Tests</div>
            <button onclick="testFingerArticulation()">Test Articulation</button>
            <button onclick="animateWave()">Saluer</button>
            <button onclick="showBones()">Voir Squelette</button>
            <button onclick="resetHands()">Reset</button>
        </div>
        
        <div class="model-info" id="status">
            Pr√™t √† charger des mod√®les de mains articul√©es professionnels
        </div>
    </div>

    <script src="../../assets/vendor/three.min.js"></script>
    <script src="../../assets/vendor/dat.gui.min.js"></script>
    <script>
        // Configuration de base Three.js
        let scene, camera, renderer, mixer, clock;
        let currentHands = { left: null, right: null };
        let animationActions = [];
        let handModels = new Map();
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3);
            camera.lookAt(0, 1.6, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // √âclairage
            setupLighting();
            
            // Clock pour animations
            clock = new THREE.Clock();
            
            // Animation mixer
            mixer = new THREE.AnimationMixer(scene);
            
            // Contr√¥les de base
            setupControls();
            
            // D√©marrer la boucle de rendu
            animate();
            
            updateStatus("Environnement 3D initialis√© - Pr√™t pour les mains articul√©es", "success");
        }
        
        function setupLighting() {
            // Lumi√®re ambiante
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Lumi√®re directionnelle principale
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            // Lumi√®re de remplissage
            const fillLight = new THREE.DirectionalLight(0x88aaff, 0.4);
            fillLight.position.set(-3, 5, -2);
            scene.add(fillLight);
            
            // Lumi√®re d'accentuation
            const rimLight = new THREE.DirectionalLight(0xff8888, 0.3);
            rimLight.position.set(0, 2, -5);
            scene.add(rimLight);
        }
        
        function setupControls() {
            // Contr√¥les souris de base
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Rotation l√©g√®re de la cam√©ra
                camera.position.x = Math.sin(mouseX * 0.2) * 3;
                camera.position.z = Math.cos(mouseX * 0.2) * 3;
                camera.lookAt(0, 1.6, 0);
            });
            
            // Gestion du redimensionnement
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Mod√®les de mains disponibles (pmndrs Market)
        const HAND_MODELS = {
            'left-white': 'https://market.pmnd.rs/api/files/left-hand-white-webxr.glb',
            'right-white': 'https://market.pmnd.rs/api/files/right-hand-white-webxr.glb',
            'left-black': 'https://market.pmnd.rs/api/files/left-hand-black-webxr.glb',
            'right-black': 'https://market.pmnd.rs/api/files/right-hand-black-webxr.glb',
            'skeleton-left': 'https://market.pmnd.rs/api/files/skeleton-left-hand-webxr.glb',
            'skeleton-right': 'https://market.pmnd.rs/api/files/skeleton-right-hand-webxr.glb'
        };
        
        async function loadHandModel(modelType) {
            updateStatus(`Chargement du mod√®le: ${modelType}...`, "loading");
            
            try {
                const url = HAND_MODELS[modelType];
                if (!url) {
                    throw new Error(`Mod√®le ${modelType} non trouv√©`);
                }
                
                // Cr√©er un loader GLTF
                const loader = new THREE.GLTFLoader();
                
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(url, resolve, undefined, reject);
                });
                
                // Traiter le mod√®le charg√©
                const hand = gltf.scene;
                
                // Positionner la main
                const isLeft = modelType.includes('left');
                hand.position.set(isLeft ? -0.3 : 0.3, 1.6, 0);
                hand.scale.setScalar(1.2);
                
                // Supprimer l'ancienne main si elle existe
                const side = isLeft ? 'left' : 'right';
                if (currentHands[side]) {
                    scene.remove(currentHands[side]);
                }
                
                // Ajouter la nouvelle main
                scene.add(hand);
                currentHands[side] = hand;
                
                // Stocker les animations si disponibles
                if (gltf.animations && gltf.animations.length > 0) {
                    const mixer = new THREE.AnimationMixer(hand);
                    gltf.animations.forEach(clip => {
                        const action = mixer.clipAction(clip);
                        animationActions.push({ action, mixer, side });
                    });
                }
                
                // Analyser la structure des os pour l'articulation
                analyzeHandBones(hand, side);
                
                updateStatus(`Mod√®le ${modelType} charg√© avec succ√®s!`, "success");
                
            } catch (error) {
                console.error('Erreur lors du chargement:', error);
                updateStatus(`Erreur: ${error.message}`, "error");
            }
        }
        
        function analyzeHandBones(hand, side) {
            const bones = [];
            hand.traverse((child) => {
                if (child.isBone) {
                    bones.push(child);
                }
            });
            
            console.log(`Main ${side}: ${bones.length} os d√©tect√©s`);
            
            // Stocker la r√©f√©rence aux os pour l'articulation
            if (!handModels.has(side)) {
                handModels.set(side, {});
            }
            handModels.get(side).bones = bones;
        }
        
        function performGesture(gestureType) {
            updateStatus(`Ex√©cution du geste: ${gestureType}`, "loading");
            
            // Gestes LSQ sp√©cifiques
            const gestures = {
                'bonjour': () => {
                    animateHandGesture('right', [
                        { bone: 'index', rotation: [0, 0, 0.2] },
                        { bone: 'middle', rotation: [0, 0, 0.1] },
                        { bone: 'ring', rotation: [0, 0, 0.1] },
                        { bone: 'pinky', rotation: [0, 0, 0.1] }
                    ]);
                },
                'merci': () => {
                    // Geste de remerciement en LSQ
                    animateHandGesture('right', [
                        { bone: 'thumb', rotation: [0, 0, 0.3] },
                        { bone: 'index', rotation: [0, 0, -0.2] }
                    ]);
                },
                'oui': () => {
                    // Acquiescement en LSQ
                    if (currentHands.right) {
                        const hand = currentHands.right;
                        const originalY = hand.position.y;
                        
                        // Animation de hochement
                        const timeline = [
                            { time: 0, y: originalY },
                            { time: 0.3, y: originalY - 0.1 },
                            { time: 0.6, y: originalY },
                            { time: 0.9, y: originalY - 0.1 },
                            { time: 1.2, y: originalY }
                        ];
                        
                        animateTimeline(hand.position, 'y', timeline);
                    }
                },
                'non': () => {
                    // N√©gation en LSQ
                    if (currentHands.right) {
                        const hand = currentHands.right;
                        const originalRotation = hand.rotation.y;
                        
                        const timeline = [
                            { time: 0, rotation: originalRotation },
                            { time: 0.3, rotation: originalRotation + 0.3 },
                            { time: 0.6, rotation: originalRotation - 0.3 },
                            { time: 0.9, rotation: originalRotation + 0.3 },
                            { time: 1.2, rotation: originalRotation }
                        ];
                        
                        animateTimeline(hand.rotation, 'y', timeline);
                    }
                },
                'maison': () => {
                    // Geste "maison" en LSQ
                    animateHandGesture('both', [
                        { bone: 'index', rotation: [0.5, 0, 0] },
                        { bone: 'middle', rotation: [0.5, 0, 0] }
                    ]);
                },
                'famille': () => {
                    // Geste "famille" en LSQ
                    animateHandGesture('both', [
                        { bone: 'thumb', rotation: [0, 0, 0.5] },
                        { bone: 'pinky', rotation: [0, 0, -0.5] }
                    ]);
                }
            };
            
            if (gestures[gestureType]) {
                gestures[gestureType]();
                updateStatus(`Geste "${gestureType}" ex√©cut√©`, "success");
            } else {
                updateStatus(`Geste "${gestureType}" non impl√©ment√©`, "error");
            }
        }
        
        function performLetter(letter) {
            updateStatus(`Lettre LSQ: ${letter}`, "loading");
            
            // Configurations sp√©cifiques pour chaque lettre de l'alphabet LSQ
            const letterConfigs = {
                'A': { thumb: [0, 0, 0.8], fingers: [0.8, 0.8, 0.8, 0.8] },
                'B': { thumb: [0.8, 0, 0], fingers: [0, 0, 0, 0] },
                'C': { thumb: [0.3, 0, 0], fingers: [0.6, 0.6, 0.6, 0.6] },
                'D': { thumb: [0.5, 0, 0], fingers: [0, 0.8, 0.8, 0.8] },
                'E': { thumb: [0.8, 0, 0], fingers: [0.9, 0.9, 0.9, 0.9] },
                'F': { thumb: [0.3, 0, 0], fingers: [0.8, 0, 0, 0] }
            };
            
            const config = letterConfigs[letter];
            if (config && currentHands.right) {
                animateLetterGesture(config);
                updateStatus(`Lettre "${letter}" en LSQ`, "success");
            } else {
                updateStatus(`Lettre "${letter}" non impl√©ment√©e`, "error");
            }
        }
        
        function animateHandGesture(side, boneRotations) {
            const hands = side === 'both' ? ['left', 'right'] : [side];
            
            hands.forEach(handSide => {
                const hand = currentHands[handSide];
                if (!hand) return;
                
                boneRotations.forEach(({ bone, rotation }) => {
                    hand.traverse((child) => {
                        if (child.isBone && child.name.toLowerCase().includes(bone)) {
                            // Animation fluide vers la nouvelle rotation
                            const targetRotation = new THREE.Euler(...rotation);
                            animateRotation(child, targetRotation, 500);
                        }
                    });
                });
            });
        }
        
        function animateLetterGesture(config) {
            const hand = currentHands.right;
            if (!hand) return;
            
            // Animer le pouce
            hand.traverse((child) => {
                if (child.isBone && child.name.toLowerCase().includes('thumb')) {
                    const rotation = new THREE.Euler(...config.thumb);
                    animateRotation(child, rotation, 300);
                }
            });
            
            // Animer les doigts
            const fingerNames = ['index', 'middle', 'ring', 'pinky'];
            fingerNames.forEach((finger, index) => {
                hand.traverse((child) => {
                    if (child.isBone && child.name.toLowerCase().includes(finger)) {
                        const rotation = new THREE.Euler(config.fingers[index], 0, 0);
                        animateRotation(child, rotation, 300);
                    }
                });
            });
        }
        
        function animateRotation(object, targetRotation, duration) {
            const startRotation = object.rotation.clone();
            const startTime = Date.now();
            
            function updateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Interpolation fluide
                const factor = 0.5 * (1 - Math.cos(progress * Math.PI));
                
                object.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * factor;
                object.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * factor;
                object.rotation.z = startRotation.z + (targetRotation.z - startRotation.z) * factor;
                
                if (progress < 1) {
                    requestAnimationFrame(updateRotation);
                }
            }
            
            updateRotation();
        }
        
        function animateTimeline(object, property, timeline) {
            const startTime = Date.now();
            const duration = timeline[timeline.length - 1].time * 1000;
            
            function updateProperty() {
                const elapsed = (Date.now() - startTime) / 1000;
                const progress = Math.min(elapsed / (duration / 1000), 1);
                
                // Trouver les points de la timeline
                let currentFrame = 0;
                for (let i = 0; i < timeline.length - 1; i++) {
                    if (elapsed >= timeline[i].time && elapsed <= timeline[i + 1].time) {
                        currentFrame = i;
                        break;
                    }
                }
                
                if (currentFrame < timeline.length - 1) {
                    const frame1 = timeline[currentFrame];
                    const frame2 = timeline[currentFrame + 1];
                    const frameProgress = (elapsed - frame1.time) / (frame2.time - frame1.time);
                    
                    const value1 = frame1[property] || frame1.y || frame1.rotation;
                    const value2 = frame2[property] || frame2.y || frame2.rotation;
                    
                    object[property] = value1 + (value2 - value1) * frameProgress;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(updateProperty);
                }
            }
            
            updateProperty();
        }
        
        function testFingerArticulation() {
            updateStatus("Test d'articulation des doigts...", "loading");
            
            ['left', 'right'].forEach(side => {
                const hand = currentHands[side];
                if (!hand) return;
                
                // Test s√©quentiel de chaque doigt
                const fingers = ['thumb', 'index', 'middle', 'ring', 'pinky'];
                
                fingers.forEach((finger, index) => {
                    setTimeout(() => {
                        hand.traverse((child) => {
                            if (child.isBone && child.name.toLowerCase().includes(finger)) {
                                // Flex puis extension
                                const flexRotation = new THREE.Euler(0.8, 0, 0);
                                animateRotation(child, flexRotation, 200);
                                
                                setTimeout(() => {
                                    const extendRotation = new THREE.Euler(0, 0, 0);
                                    animateRotation(child, extendRotation, 200);
                                }, 300);
                            }
                        });
                    }, index * 400);
                });
            });
            
            updateStatus("Test d'articulation termin√©", "success");
        }
        
        function animateWave() {
            const hand = currentHands.right;
            if (!hand) {
                updateStatus("Aucune main droite charg√©e", "error");
                return;
            }
            
            updateStatus("Animation de salut...", "loading");
            
            // Animation de salut
            const waveSequence = [
                { time: 0, rotation: 0 },
                { time: 0.2, rotation: 0.3 },
                { time: 0.4, rotation: -0.3 },
                { time: 0.6, rotation: 0.3 },
                { time: 0.8, rotation: -0.3 },
                { time: 1.0, rotation: 0 }
            ];
            
            animateTimeline(hand.rotation, 'z', waveSequence);
            
            setTimeout(() => {
                updateStatus("Salut termin√©", "success");
            }, 1200);
        }
        
        function showBones() {
            ['left', 'right'].forEach(side => {
                const hand = currentHands[side];
                if (!hand) return;
                
                hand.traverse((child) => {
                    if (child.isBone) {
                        // Cr√©er un helper visuel pour chaque os
                        const helper = new THREE.AxesHelper(0.05);
                        child.add(helper);
                        
                        // Supprimer apr√®s 3 secondes
                        setTimeout(() => {
                            child.remove(helper);
                        }, 3000);
                    }
                });
            });
            
            updateStatus("Visualisation du squelette (3s)", "success");
        }
        
        function resetHands() {
            ['left', 'right'].forEach(side => {
                const hand = currentHands[side];
                if (!hand) return;
                
                // Reset toutes les rotations des os
                hand.traverse((child) => {
                    if (child.isBone) {
                        animateRotation(child, new THREE.Euler(0, 0, 0), 500);
                    }
                });
                
                // Reset position et rotation de la main
                const isLeft = side === 'left';
                hand.position.set(isLeft ? -0.3 : 0.3, 1.6, 0);
                hand.rotation.set(0, 0, 0);
            });
            
            updateStatus("Mains r√©initialis√©es", "success");
        }
        
        function updateStatus(message, type = "normal") {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `model-info ${type}`;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Mettre √† jour les animations
            animationActions.forEach(({ mixer }) => {
                mixer.update(delta);
            });
            
            // Rotation automatique l√©g√®re des mains
            ['left', 'right'].forEach(side => {
                const hand = currentHands[side];
                if (hand) {
                    hand.rotation.y += Math.sin(Date.now() * 0.001) * 0.002;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Initialisation
        init();
        
        // Message de bienvenue
        setTimeout(() => {
            updateStatus("üñêÔ∏è Chargez un mod√®le de main pour commencer!", "loading");
        }, 1000);
    </script>
</body>
</html>
