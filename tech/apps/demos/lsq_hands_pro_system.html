<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LSQ - Syst√®me de Mains Articul√©es Avanc√©</title>
    <style>
        body {
            margin: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            backdrop-filter: blur(15px);
            max-width: 380px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        
        .title {
            color: #00ff88;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .section {
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(0, 50, 25, 0.3);
            border-radius: 8px;
            border-left: 3px solid #00ff88;
        }
        
        .section-title {
            color: #88ffaa;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button {
            background: linear-gradient(145deg, #1a4a3a, #0d2d1d);
            color: #ffffff;
            border: 1px solid #00ff88;
            padding: 10px 15px;
            margin: 4px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            background: linear-gradient(145deg, #2a6a4a, #1d4d2d);
            border-color: #44ff99;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }
        
        .model-info {
            background: rgba(0, 100, 50, 0.4);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 13px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        .loading {
            color: #ffaa00;
            font-style: italic;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        .success {
            color: #00ff88;
            font-weight: bold;
        }
        
        .error {
            color: #ff4444;
            font-weight: bold;
        }
        
        @keyframes pulse {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .finger-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
        }
        
        .anatomy-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff6600;
            backdrop-filter: blur(10px);
            max-width: 250px;
            color: #ffaa66;
        }
        
        .bone-indicator {
            font-size: 11px;
            margin: 2px 0;
            padding: 2px 5px;
            background: rgba(255, 102, 0, 0.2);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="ui">
        <div class="title">üñêÔ∏è LSQ - Mains Articul√©es Pro</div>
        
        <div class="section">
            <div class="section-title">üéØ Mod√®les Disponibles</div>
            <div class="controls-grid">
                <button onclick="loadAdvancedHand('left')">Main Gauche</button>
                <button onclick="loadAdvancedHand('right')">Main Droite</button>
                <button onclick="loadAdvancedHand('both')">Les Deux</button>
                <button onclick="loadSkeletonHand()">Mode Squelette</button>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">ü§ü Gestes LSQ Complexes</div>
            <div class="controls-grid">
                <button onclick="performComplexGesture('je_taime')">Je t'aime</button>
                <button onclick="performComplexGesture('bonjour_lsq')">Bonjour LSQ</button>
                <button onclick="performComplexGesture('merci_beaucoup')">Merci beaucoup</button>
                <button onclick="performComplexGesture('comment_ca_va')">Comment √ßa va?</button>
                <button onclick="performComplexGesture('au_revoir')">Au revoir</button>
                <button onclick="performComplexGesture('je_comprends')">Je comprends</button>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">üî§ Alphabet LSQ Pr√©cis</div>
            <div class="finger-controls">
                <button onclick="performPreciseLetter('A')">A</button>
                <button onclick="performPreciseLetter('B')">B</button>
                <button onclick="performPreciseLetter('C')">C</button>
                <button onclick="performPreciseLetter('D')">D</button>
                <button onclick="performPreciseLetter('E')">E</button>
                <button onclick="performPreciseLetter('F')">F</button>
                <button onclick="performPreciseLetter('G')">G</button>
                <button onclick="performPreciseLetter('H')">H</button>
                <button onclick="performPreciseLetter('I')">I</button>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">üëÅÔ∏è Mode Affichage</div>
            <div class="controls-grid">
                <button onclick="alphabetDisplay.setDisplayMode('auto')" id="btn-auto">ü§ñ Auto</button>
                <button onclick="alphabetDisplay.setDisplayMode('hand-only')" id="btn-hand">ü§≤ Main Seule</button>
                <button onclick="alphabetDisplay.setDisplayMode('full-body')" id="btn-body">üßç Corps Complet</button>
            </div>
            <div style="font-size: 11px; margin-top: 8px; color: #88ffaa;">
                Auto: Main seule pour A,E,I,O,S,T,L ‚Ä¢ Corps complet pour autres
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">‚öôÔ∏è Contr√¥les Avanc√©s</div>
            <div class="controls-grid">
                <button onclick="testArticulationComplete()">Test Complet</button>
                <button onclick="anatomyMode()">Mode Anatomie</button>
                <button onclick="mirrorHands()">Effet Miroir</button>
                <button onclick="handPhysics()">Physique</button>
                <button onclick="saveGesture()">Sauvegarder</button>
                <button onclick="resetToBase()">Reset</button>
            </div>
        </div>
        
        <div class="model-info" id="status">
            Syst√®me LSQ avanc√© initialis√© - Mod√®les de mains articul√©es pr√™ts
        </div>
    </div>
    
    <div class="anatomy-panel" id="anatomy" style="display: none;">
        <div style="color: #ff6600; font-weight: bold; margin-bottom: 10px;">ü¶¥ Anatomie de la Main</div>
        <div id="bone-list"></div>
    </div>

    <script src="../../assets/vendor/three.min.js"></script>
    <script src="../../assets/vendor/dat.gui.min.js"></script>
    <script>
        // Configuration avanc√©e Three.js
        let scene, camera, renderer, mixer, clock;
        let currentHands = { left: null, right: null };
        let handControllers = { left: null, right: null };
        let anatomyHelpers = [];
        let physicsWorld = null;
        let isAnatomyMode = false;
        
        // Syst√®me d'affichage alphabet LSQ optimis√©
        class LSQAlphabetDisplay {
            constructor() {
                this.displayMode = 'auto'; // 'hand-only', 'full-body', 'auto'
                this.currentSymbol = null;
                this.bodyParts = { torso: null, arms: null, hands: null };
                this.alphabetComplexity = this.initializeAlphabetComplexity();
            }
            
            initializeAlphabetComplexity() {
                // Classification des lettres selon leur complexit√© gestuelle
                return {
                    'hand-only': ['A', 'E', 'I', 'O', 'S', 'T', 'L'], // Positions statiques simples
                    'full-body': ['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'N', 'P', 'Q', 'R', 'U', 'V', 'W', 'X', 'Y', 'Z'] // Mouvements complexes
                };
            }
            
            getDisplayModeForSymbol(symbol) {
                if (this.displayMode !== 'auto') return this.displayMode;
                
                if (this.alphabetComplexity['hand-only'].includes(symbol)) {
                    return 'hand-only';
                } else if (this.alphabetComplexity['full-body'].includes(symbol)) {
                    return 'full-body';
                } else {
                    return 'hand-only'; // par d√©faut
                }
            }
            
            setDisplayMode(mode) {
                this.displayMode = mode;
                if (this.currentSymbol) {
                    this.updateDisplay(this.currentSymbol);
                }
            }
            
            updateDisplay(symbol) {
                const mode = this.getDisplayModeForSymbol(symbol);
                this.currentSymbol = symbol;
                
                // Gestion de la visibilit√© selon le mode
                if (mode === 'hand-only') {
                    this.showHandOnly();
                    updateStatus(`ü§≤ Mode main seule - Lettre ${symbol}`, "success");
                } else {
                    this.showFullBody();
                    updateStatus(`üßç Mode corps complet - Lettre ${symbol}`, "success");
                }
            }
            
            showHandOnly() {
                // Masquer torso et bras, focus sur main droite
                this.hideBodyParts(['torso', 'leftArm', 'leftHand']);
                this.highlightRightHand();
                
                // Ajuster la cam√©ra pour focus main
                if (camera && currentHands.right) {
                    const handPos = currentHands.right.position;
                    camera.position.set(handPos.x + 1, handPos.y + 0.5, handPos.z + 2);
                    camera.lookAt(handPos);
                }
            }
            
            showFullBody() {
                // Afficher torso, bras et mains d√©taill√©es
                this.showBodyParts(['torso', 'leftArm', 'rightArm', 'leftHand', 'rightHand']);
                
                // Ajuster la cam√©ra pour vue compl√®te
                if (camera) {
                    camera.position.set(0, 1.5, 4);
                    camera.lookAt(0, 1, 0);
                }
            }
            
            hideBodyParts(parts) {
                parts.forEach(part => {
                    if (this.bodyParts[part]) {
                        this.bodyParts[part].visible = false;
                    }
                });
            }
            
            showBodyParts(parts) {
                parts.forEach(part => {
                    if (this.bodyParts[part]) {
                        this.bodyParts[part].visible = true;
                    }
                });
            }
            
            highlightRightHand() {
                if (currentHands.right) {
                    // Effet de mise en √©vidence
                    const highlightLight = new THREE.PointLight(0x00ff88, 1.5, 3);
                    highlightLight.position.copy(currentHands.right.position);
                    highlightLight.position.z += 1;
                    scene.add(highlightLight);
                    
                    setTimeout(() => scene.remove(highlightLight), 3000);
                }
            }
        }
        
        // Instance globale du syst√®me d'affichage
        let alphabetDisplay = new LSQAlphabetDisplay();
        
        // Syst√®me de gestion des os de la main
        class HandBoneSystem {
            constructor(hand, side) {
                this.hand = hand;
                this.side = side;
                this.bones = new Map();
                this.joints = new Map();
                this.constraints = new Map();
                this.analyzeBones();
            }
            
            analyzeBones() {
                this.hand.traverse((child) => {
                    if (child.isBone) {
                        const boneName = child.name.toLowerCase();
                        
                        // Classification anatomique des os
                        if (boneName.includes('thumb')) {
                            this.bones.set('thumb', child);
                        } else if (boneName.includes('index')) {
                            this.bones.set('index', child);
                        } else if (boneName.includes('middle')) {
                            this.bones.set('middle', child);
                        } else if (boneName.includes('ring')) {
                            this.bones.set('ring', child);
                        } else if (boneName.includes('pinky')) {
                            this.bones.set('pinky', child);
                        } else if (boneName.includes('wrist')) {
                            this.bones.set('wrist', child);
                        } else if (boneName.includes('metacarpal')) {
                            this.bones.set('metacarpal', child);
                        }
                        
                        // Analyse des articulations
                        this.analyzeJoint(child);
                    }
                });
                
                console.log(`Main ${this.side}: ${this.bones.size} os principaux identifi√©s`);
            }
            
            analyzeJoint(bone) {
                // Calcul des limites d'articulation r√©alistes
                const jointLimits = {
                    'thumb': { x: [-0.5, 1.0], y: [-0.3, 0.3], z: [-0.2, 1.2] },
                    'index': { x: [-0.1, 1.6], y: [-0.2, 0.2], z: [-0.1, 0.1] },
                    'middle': { x: [-0.1, 1.6], y: [-0.1, 0.1], z: [-0.1, 0.1] },
                    'ring': { x: [-0.1, 1.5], y: [-0.1, 0.1], z: [-0.1, 0.1] },
                    'pinky': { x: [-0.1, 1.4], y: [-0.2, 0.2], z: [-0.1, 0.1] },
                    'wrist': { x: [-0.8, 0.8], y: [-0.5, 0.5], z: [-0.3, 0.3] }
                };
                
                const boneName = bone.name.toLowerCase();
                for (const [joint, limits] of Object.entries(jointLimits)) {
                    if (boneName.includes(joint)) {
                        this.constraints.set(bone, limits);
                        break;
                    }
                }
            }
            
            setFingerPose(fingerName, pose) {
                const bone = this.bones.get(fingerName);
                if (!bone) return;
                
                const constraints = this.constraints.get(bone);
                if (constraints) {
                    // Application des contraintes anatomiques
                    const clampedPose = {
                        x: Math.max(constraints.x[0], Math.min(constraints.x[1], pose.x)),
                        y: Math.max(constraints.y[0], Math.min(constraints.y[1], pose.y)),
                        z: Math.max(constraints.z[0], Math.min(constraints.z[1], pose.z))
                    };
                    
                    animateRotation(bone, new THREE.Euler(clampedPose.x, clampedPose.y, clampedPose.z), 300);
                }
            }
            
            performNaturalGesture(gestureData) {
                // Application de gestes avec physique naturelle
                Object.entries(gestureData).forEach(([finger, pose]) => {
                    setTimeout(() => {
                        this.setFingerPose(finger, pose);
                    }, pose.delay || 0);
                });
            }
        }
        
        function init() {
            // Scene avec environnement am√©lior√©
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);
            
            // Camera cin√©matique
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 2.5);
            camera.lookAt(0, 1.4, 0);
            
            // Renderer avec qualit√© maximale
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.4;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            document.getElementById('container').appendChild(renderer.domElement);
            
            // √âclairage cin√©matique
            setupAdvancedLighting();
            
            // Environnement
            setupEnvironment();
            
            clock = new THREE.Clock();
            mixer = new THREE.AnimationMixer(scene);
            
            setupAdvancedControls();
            animate();
            
            updateStatus("üöÄ Syst√®me LSQ Pro initialis√© avec succ√®s!", "success");
        }
        
        function setupAdvancedLighting() {
            // √âclairage ambiant doux
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);
            
            // Lumi√®re principale (key light)
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
            keyLight.position.set(3, 8, 5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 4096;
            keyLight.shadow.mapSize.height = 4096;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.camera.left = -10;
            keyLight.shadow.camera.right = 10;
            keyLight.shadow.camera.top = 10;
            keyLight.shadow.camera.bottom = -10;
            scene.add(keyLight);
            
            // Lumi√®re de remplissage (fill light)
            const fillLight = new THREE.DirectionalLight(0x88aaff, 0.6);
            fillLight.position.set(-3, 5, -2);
            scene.add(fillLight);
            
            // Lumi√®re d'accentuation (rim light)
            const rimLight = new THREE.DirectionalLight(0xff8844, 0.4);
            rimLight.position.set(0, 2, -8);
            scene.add(rimLight);
            
            // Lumi√®res d'appoint color√©es
            const accent1 = new THREE.PointLight(0x00ff88, 0.5, 10);
            accent1.position.set(-2, 3, 1);
            scene.add(accent1);
            
            const accent2 = new THREE.PointLight(0xff6600, 0.3, 8);
            accent2.position.set(2, 1, -1);
            scene.add(accent2);
        }
        
        function setupEnvironment() {
            // Sol r√©fl√©chissant
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333344, 
                transparent: true, 
                opacity: 0.8 
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Particules d'ambiance
            createAmbientParticles();
        }
        
        function createAmbientParticles() {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 20;
                positions[i + 1] = Math.random() * 10;
                positions[i + 2] = (Math.random() - 0.5) * 20;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ff88,
                size: 0.02,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        function setupAdvancedControls() {
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                
                if (!isMouseDown) {
                    // Mouvement cin√©matique de la cam√©ra
                    const targetX = Math.sin(mouseX * 0.3) * 2.5;
                    const targetY = 1.6 + mouseY * 0.3;
                    const targetZ = Math.cos(mouseX * 0.3) * 2.5;
                    
                    camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.02);
                    camera.lookAt(0, 1.4, 0);
                }
            });
            
            document.addEventListener('mousedown', () => { isMouseDown = true; });
            document.addEventListener('mouseup', () => { isMouseDown = false; });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function loadAdvancedHand(side) {
            updateStatus(`Cr√©ation de main articul√©e avanc√©e: ${side}...`, "loading");
            
            const sides = side === 'both' ? ['left', 'right'] : [side];
            
            sides.forEach(handSide => {
                // Cr√©er une main proc√©durale avec anatomie r√©aliste
                const hand = createAdvancedHandModel(handSide);
                
                // Positionnement
                const isLeft = handSide === 'left';
                hand.position.set(isLeft ? -0.4 : 0.4, 1.4, 0);
                hand.scale.setScalar(1.5);
                
                // Supprimer l'ancienne main
                if (currentHands[handSide]) {
                    scene.remove(currentHands[handSide]);
                }
                
                scene.add(hand);
                currentHands[handSide] = hand;
                
                // Cr√©er le syst√®me de contr√¥le des os
                handControllers[handSide] = new HandBoneSystem(hand, handSide);
                
                console.log(`Main ${handSide} cr√©√©e avec syst√®me osseux avanc√©`);
            });
            
            updateStatus("‚úÖ Mains articul√©es avanc√©es charg√©es!", "success");
        }
        
        function createAdvancedHandModel(side) {
            const hand = new THREE.Group();
            hand.name = `hand_${side}`;
            
            // Cr√©ation proc√©durale de la main avec os individuels
            const fingerNames = ['thumb', 'index', 'middle', 'ring', 'pinky'];
            const fingerLengths = [0.8, 1.0, 1.1, 1.0, 0.8];
            const fingerPositions = [
                { x: 0.3, z: 0.2 },   // thumb
                { x: 0.2, z: 0 },     // index  
                { x: 0.0, z: 0 },     // middle
                { x: -0.2, z: 0 },    // ring
                { x: -0.35, z: -0.1 } // pinky
            ];
            
            // Cr√©er la paume
            const palmGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.8);
            const palmMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffcc99,
                shininess: 30
            });
            const palm = new THREE.Mesh(palmGeometry, palmMaterial);
            palm.castShadow = true;
            palm.receiveShadow = true;
            hand.add(palm);
            
            // Cr√©er les doigts avec articulations
            fingerNames.forEach((fingerName, index) => {
                const finger = createArticulatedFinger(
                    fingerName, 
                    fingerLengths[index], 
                    fingerPositions[index]
                );
                hand.add(finger);
            });
            
            // Cr√©er le poignet
            const wristGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.3, 8);
            const wristMaterial = new THREE.MeshPhongMaterial({ color: 0xffcc99 });
            const wrist = new THREE.Mesh(wristGeometry, wristMaterial);
            wrist.position.y = -0.4;
            wrist.name = 'wrist';
            wrist.isBone = true;
            hand.add(wrist);
            
            return hand;
        }
        
        function createArticulatedFinger(name, length, position) {
            const finger = new THREE.Group();
            finger.name = name;
            finger.position.set(position.x, 0.05, position.z);
            
            // Cr√©er 3 phalanges par doigt
            const phalangeCount = name === 'thumb' ? 2 : 3;
            const phalangeLength = length / phalangeCount;
            
            let currentBone = finger;
            
            for (let i = 0; i < phalangeCount; i++) {
                const phalangeGeometry = new THREE.CapsuleGeometry(0.03, phalangeLength * 0.8, 4, 8);
                const phalangeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffcc99,
                    shininess: 50
                });
                const phalange = new THREE.Mesh(phalangeGeometry, phalangeMaterial);
                
                phalange.position.y = phalangeLength * 0.5;
                phalange.castShadow = true;
                phalange.receiveShadow = true;
                phalange.name = `${name}_phalange_${i}`;
                phalange.isBone = true;
                
                // Cr√©er un pivot pour l'articulation
                const joint = new THREE.Group();
                joint.name = `${name}_joint_${i}`;
                joint.position.y = i > 0 ? phalangeLength : 0;
                joint.isBone = true;
                
                joint.add(phalange);
                currentBone.add(joint);
                currentBone = joint;
            }
            
            return finger;
        }
        
        function performComplexGesture(gestureType) {
            updateStatus(`Geste LSQ complexe: ${gestureType}`, "loading");
            
            const complexGestures = {
                'je_taime': {
                    thumb: { x: 0, y: 0, z: 0.8, delay: 0 },
                    index: { x: 0, y: 0, z: 0, delay: 100 },
                    middle: { x: 1.4, y: 0, z: 0, delay: 200 },
                    ring: { x: 1.4, y: 0, z: 0, delay: 200 },
                    pinky: { x: 0, y: 0, z: 0, delay: 300 }
                },
                'bonjour_lsq': {
                    thumb: { x: 0.2, y: 0, z: 0.3, delay: 0 },
                    index: { x: 0, y: 0, z: 0, delay: 50 },
                    middle: { x: 0, y: 0, z: 0, delay: 100 },
                    ring: { x: 0, y: 0, z: 0, delay: 150 },
                    pinky: { x: 0, y: 0, z: 0, delay: 200 }
                },
                'merci_beaucoup': {
                    thumb: { x: 0, y: 0, z: 1.0, delay: 0 },
                    index: { x: 0.3, y: 0, z: 0, delay: 100 },
                    middle: { x: 0.3, y: 0, z: 0, delay: 150 },
                    ring: { x: 0.3, y: 0, z: 0, delay: 200 },
                    pinky: { x: 0.3, y: 0, z: 0, delay: 250 }
                },
                'comment_ca_va': {
                    thumb: { x: 0.5, y: 0, z: 0.5, delay: 0 },
                    index: { x: 0, y: 0.2, z: 0, delay: 100 },
                    middle: { x: 1.2, y: 0, z: 0, delay: 200 },
                    ring: { x: 1.2, y: 0, z: 0, delay: 200 },
                    pinky: { x: 1.2, y: 0, z: 0, delay: 200 }
                },
                'au_revoir': {
                    thumb: { x: 0, y: 0, z: 0.2, delay: 0 },
                    index: { x: 0, y: 0, z: 0, delay: 0 },
                    middle: { x: 0, y: 0, z: 0, delay: 0 },
                    ring: { x: 0, y: 0, z: 0, delay: 0 },
                    pinky: { x: 0, y: 0, z: 0, delay: 0 }
                },
                'je_comprends': {
                    thumb: { x: 0.8, y: 0, z: 0.8, delay: 0 },
                    index: { x: 0, y: 0, z: 0, delay: 100 },
                    middle: { x: 0.5, y: 0, z: 0, delay: 200 },
                    ring: { x: 1.0, y: 0, z: 0, delay: 300 },
                    pinky: { x: 1.2, y: 0, z: 0, delay: 400 }
                }
            };
            
            const gesture = complexGestures[gestureType];
            if (gesture) {
                ['left', 'right'].forEach(side => {
                    const controller = handControllers[side];
                    if (controller) {
                        controller.performNaturalGesture(gesture);
                    }
                });
                
                // Animation suppl√©mentaire pour certains gestes
                if (gestureType === 'au_revoir') {
                    setTimeout(() => animateWaveGesture(), 500);
                }
                
                updateStatus(`‚úÖ Geste "${gestureType}" ex√©cut√© avec succ√®s`, "success");
            } else {
                updateStatus(`‚ùå Geste "${gestureType}" non disponible`, "error");
            }
        }
        
        function performPreciseLetter(letter) {
            updateStatus(`Lettre LSQ pr√©cise: ${letter}`, "loading");
            
            // Mise √† jour de l'affichage selon la complexit√©
            alphabetDisplay.updateDisplay(letter);
            
            // Configurations anatomiquement pr√©cises pour l'alphabet LSQ
            const preciseLSQAlphabet = {
                'A': { thumb: [0, 0, 0.9], index: [1.4, 0, 0], middle: [1.4, 0, 0], ring: [1.4, 0, 0], pinky: [1.4, 0, 0] },
                'B': { thumb: [0.8, 0, 0.2], index: [0, 0, 0], middle: [0, 0, 0], ring: [0, 0, 0], pinky: [0, 0, 0] },
                'C': { thumb: [0.4, 0, 0], index: [0.7, 0, 0], middle: [0.7, 0, 0], ring: [0.7, 0, 0], pinky: [0.7, 0, 0] },
                'D': { thumb: [0.5, 0, 0.3], index: [0, 0, 0], middle: [1.2, 0, 0], ring: [1.2, 0, 0], pinky: [1.2, 0, 0] },
                'E': { thumb: [0.9, 0, 0.2], index: [1.5, 0, 0], middle: [1.5, 0, 0], ring: [1.5, 0, 0], pinky: [1.5, 0, 0] },
                'F': { thumb: [0.3, 0, 0.2], index: [1.2, 0, 0], middle: [0, 0, 0], ring: [0, 0, 0], pinky: [0, 0, 0] },
                'G': { thumb: [0, 0, 0.8], index: [0, 0.3, 0], middle: [1.4, 0, 0], ring: [1.4, 0, 0], pinky: [1.4, 0, 0] },
                'H': { thumb: [0, 0, 0.8], index: [0, 0.3, 0], middle: [0, 0.3, 0], ring: [1.4, 0, 0], pinky: [1.4, 0, 0] },
                'I': { thumb: [0.8, 0, 0.2], index: [1.4, 0, 0], middle: [1.4, 0, 0], ring: [1.4, 0, 0], pinky: [0, 0, 0] }
            };
            
            const config = preciseLSQAlphabet[letter];
            if (config) {
                const controller = handControllers.right;
                if (controller) {
                    // Application pr√©cise avec contraintes anatomiques
                    ['thumb', 'index', 'middle', 'ring', 'pinky'].forEach((finger, idx) => {
                        const pose = {
                            x: config[finger][0],
                            y: config[finger][1], 
                            z: config[finger][2]
                        };
                        setTimeout(() => {
                            controller.setFingerPose(finger, pose);
                        }, idx * 50);
                    });
                    
                    updateStatus(`‚úÖ Lettre "${letter}" LSQ form√©e`, "success");
                } else {
                    updateStatus("‚ùå Main droite non disponible", "error");
                }
            } else {
                updateStatus(`‚ùå Lettre "${letter}" non impl√©ment√©e`, "error");
            }
        }
        
        function animateWaveGesture() {
            const hand = currentHands.right;
            if (!hand) return;
            
            // Animation de salut fluide
            const waveKeyframes = [
                { rotation: 0, time: 0 },
                { rotation: 0.4, time: 200 },
                { rotation: -0.3, time: 400 },
                { rotation: 0.4, time: 600 },
                { rotation: -0.3, time: 800 },
                { rotation: 0, time: 1000 }
            ];
            
            animateKeyframes(hand.rotation, 'z', waveKeyframes);
        }
        
        function testArticulationComplete() {
            updateStatus("üî¨ Test d'articulation anatomique complet...", "loading");
            
            ['left', 'right'].forEach(side => {
                const controller = handControllers[side];
                if (!controller) return;
                
                const fingers = ['thumb', 'index', 'middle', 'ring', 'pinky'];
                
                // Test s√©quentiel avec physique r√©aliste
                fingers.forEach((finger, index) => {
                    setTimeout(() => {
                        // Flexion maximale
                        controller.setFingerPose(finger, { x: 1.5, y: 0, z: 0 });
                        
                        setTimeout(() => {
                            // Extension
                            controller.setFingerPose(finger, { x: 0, y: 0, z: 0 });
                            
                            setTimeout(() => {
                                // Mouvement lat√©ral
                                controller.setFingerPose(finger, { x: 0, y: 0.3, z: 0 });
                                
                                setTimeout(() => {
                                    // Retour au neutre
                                    controller.setFingerPose(finger, { x: 0, y: 0, z: 0 });
                                }, 200);
                            }, 200);
                        }, 300);
                    }, index * 800);
                });
            });
            
            setTimeout(() => {
                updateStatus("‚úÖ Test d'articulation termin√© - Toutes les contraintes respect√©es", "success");
            }, 5000);
        }
        
        function anatomyMode() {
            isAnatomyMode = !isAnatomyMode;
            const anatomyPanel = document.getElementById('anatomy');
            
            if (isAnatomyMode) {
                anatomyPanel.style.display = 'block';
                showAnatomyInfo();
                updateStatus("ü¶¥ Mode anatomie activ√©", "success");
            } else {
                anatomyPanel.style.display = 'none';
                hideAnatomyHelpers();
                updateStatus("Mode anatomie d√©sactiv√©", "success");
            }
        }
        
        function showAnatomyInfo() {
            const boneList = document.getElementById('bone-list');
            boneList.innerHTML = '';
            
            ['left', 'right'].forEach(side => {
                const controller = handControllers[side];
                if (!controller) return;
                
                const sideDiv = document.createElement('div');
                sideDiv.innerHTML = `<strong>Main ${side}:</strong>`;
                boneList.appendChild(sideDiv);
                
                controller.bones.forEach((bone, name) => {
                    const boneDiv = document.createElement('div');
                    boneDiv.className = 'bone-indicator';
                    boneDiv.textContent = `${name}: ${bone.name}`;
                    boneList.appendChild(boneDiv);
                    
                    // Cr√©er helper visuel
                    const helper = new THREE.AxesHelper(0.1);
                    bone.add(helper);
                    anatomyHelpers.push(helper);
                });
            });
        }
        
        function hideAnatomyHelpers() {
            anatomyHelpers.forEach(helper => {
                if (helper.parent) {
                    helper.parent.remove(helper);
                }
            });
            anatomyHelpers = [];
        }
        
        function mirrorHands() {
            if (!currentHands.left || !currentHands.right) {
                updateStatus("‚ùå Deux mains n√©cessaires pour l'effet miroir", "error");
                return;
            }
            
            updateStatus("ü™û Effet miroir activ√©", "loading");
            
            // Synchroniser les mouvements
            const leftController = handControllers.left;
            const rightController = handControllers.right;
            
            if (leftController && rightController) {
                ['thumb', 'index', 'middle', 'ring', 'pinky'].forEach(finger => {
                    const leftBone = leftController.bones.get(finger);
                    const rightBone = rightController.bones.get(finger);
                    
                    if (leftBone && rightBone) {
                        // Cr√©er animation miroir
                        const mirrorAnimation = () => {
                            rightBone.rotation.copy(leftBone.rotation);
                            rightBone.rotation.y *= -1; // Inversion pour effet miroir
                        };
                        
                        // Appliquer pendant 3 secondes
                        const interval = setInterval(mirrorAnimation, 50);
                        setTimeout(() => {
                            clearInterval(interval);
                            updateStatus("Effet miroir termin√©", "success");
                        }, 3000);
                    }
                });
            }
        }
        
        function handPhysics() {
            updateStatus("‚öóÔ∏è Simulation physique des mains...", "loading");
            
            // Ajouter simulation de gravit√© et collision
            ['left', 'right'].forEach(side => {
                const hand = currentHands[side];
                if (!hand) return;
                
                // Animation de chute libre puis rebond
                const originalY = hand.position.y;
                const fallAnimation = [
                    { time: 0, y: originalY },
                    { time: 1000, y: originalY - 0.8 },
                    { time: 1200, y: originalY - 0.6 },
                    { time: 1400, y: originalY - 0.7 },
                    { time: 1500, y: originalY }
                ];
                
                animateKeyframes(hand.position, 'y', fallAnimation);
            });
            
            setTimeout(() => {
                updateStatus("‚úÖ Simulation physique termin√©e", "success");
            }, 2000);
        }
        
        function saveGesture() {
            updateStatus("üíæ Sauvegarde du geste actuel...", "loading");
            
            const gestureData = {};
            
            ['left', 'right'].forEach(side => {
                const controller = handControllers[side];
                if (!controller) return;
                
                gestureData[side] = {};
                controller.bones.forEach((bone, name) => {
                    gestureData[side][name] = {
                        rotation: bone.rotation.toArray(),
                        position: bone.position.toArray()
                    };
                });
            });
            
            // Simuler la sauvegarde
            localStorage.setItem('lsq_saved_gesture', JSON.stringify(gestureData));
            
            updateStatus("‚úÖ Geste sauvegard√© avec succ√®s", "success");
        }
        
        function resetToBase() {
            updateStatus("üîÑ R√©initialisation...", "loading");
            
            ['left', 'right'].forEach(side => {
                const controller = handControllers[side];
                if (!controller) return;
                
                // Reset toutes les articulations
                controller.bones.forEach((bone) => {
                    animateRotation(bone, new THREE.Euler(0, 0, 0), 500);
                });
                
                // Reset position de la main
                const hand = currentHands[side];
                if (hand) {
                    const isLeft = side === 'left';
                    hand.position.set(isLeft ? -0.4 : 0.4, 1.4, 0);
                    hand.rotation.set(0, 0, 0);
                }
            });
            
            // Cacher l'anatomie si active
            if (isAnatomyMode) {
                anatomyMode();
            }
            
            setTimeout(() => {
                updateStatus("‚úÖ R√©initialisation termin√©e", "success");
            }, 600);
        }
        
        function loadSkeletonHand() {
            updateStatus("ü¶¥ Chargement du mode squelette...", "loading");
            
            ['left', 'right'].forEach(side => {
                const hand = createSkeletonHand(side);
                
                if (currentHands[side]) {
                    scene.remove(currentHands[side]);
                }
                
                scene.add(hand);
                currentHands[side] = hand;
                handControllers[side] = new HandBoneSystem(hand, side);
            });
            
            updateStatus("‚úÖ Mode squelette activ√©", "success");
        }
        
        function createSkeletonHand(side) {
            const hand = new THREE.Group();
            
            // Mat√©riau squelette
            const boneMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffcc,
                transparent: true,
                opacity: 0.9,
                wireframe: false
            });
            
            // Cr√©er structure osseuse visible
            const fingerNames = ['thumb', 'index', 'middle', 'ring', 'pinky'];
            const fingerPositions = [
                { x: 0.3, z: 0.2 },
                { x: 0.2, z: 0 },
                { x: 0.0, z: 0 },
                { x: -0.2, z: 0 },
                { x: -0.35, z: -0.1 }
            ];
            
            fingerNames.forEach((fingerName, index) => {
                const finger = createSkeletonFinger(fingerName, fingerPositions[index], boneMaterial);
                hand.add(finger);
            });
            
            // Paume squelettique
            const palmGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.7);
            const palm = new THREE.Mesh(palmGeometry, boneMaterial);
            hand.add(palm);
            
            const isLeft = side === 'left';
            hand.position.set(isLeft ? -0.4 : 0.4, 1.4, 0);
            
            return hand;
        }
        
        function createSkeletonFinger(name, position, material) {
            const finger = new THREE.Group();
            finger.name = name;
            finger.position.set(position.x, 0, position.z);
            
            const phalangeCount = name === 'thumb' ? 2 : 3;
            const phalangeLength = 0.25;
            
            let currentBone = finger;
            
            for (let i = 0; i < phalangeCount; i++) {
                const boneGeometry = new THREE.CapsuleGeometry(0.02, phalangeLength, 4, 8);
                const bone = new THREE.Mesh(boneGeometry, material);
                
                bone.position.y = phalangeLength * 0.5;
                bone.name = `${name}_bone_${i}`;
                bone.isBone = true;
                
                const joint = new THREE.Group();
                joint.name = `${name}_joint_${i}`;
                joint.position.y = i > 0 ? phalangeLength : 0;
                joint.isBone = true;
                
                joint.add(bone);
                currentBone.add(joint);
                currentBone = joint;
            }
            
            return finger;
        }
        
        // Utilitaires d'animation
        function animateRotation(object, targetRotation, duration) {
            const startRotation = object.rotation.clone();
            const startTime = Date.now();
            
            function updateRotation() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing avec courbe smooth
                const factor = 0.5 * (1 - Math.cos(progress * Math.PI));
                
                object.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * factor;
                object.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * factor;
                object.rotation.z = startRotation.z + (targetRotation.z - startRotation.z) * factor;
                
                if (progress < 1) {
                    requestAnimationFrame(updateRotation);
                }
            }
            
            updateRotation();
        }
        
        function animateKeyframes(object, property, keyframes) {
            const startTime = Date.now();
            const totalDuration = keyframes[keyframes.length - 1].time;
            
            function updateProperty() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / totalDuration, 1);
                
                // Trouver keyframes appropri√©es
                let currentKeyframe = 0;
                for (let i = 0; i < keyframes.length - 1; i++) {
                    if (elapsed >= keyframes[i].time && elapsed <= keyframes[i + 1].time) {
                        currentKeyframe = i;
                        break;
                    }
                }
                
                if (currentKeyframe < keyframes.length - 1) {
                    const key1 = keyframes[currentKeyframe];
                    const key2 = keyframes[currentKeyframe + 1];
                    const localProgress = (elapsed - key1.time) / (key2.time - key1.time);
                    
                    const value1 = key1[property] || key1.y || key1.rotation;
                    const value2 = key2[property] || key2.y || key2.rotation;
                    
                    object[property] = value1 + (value2 - value1) * localProgress;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(updateProperty);
                }
            }
            
            updateProperty();
        }
        
        function updateStatus(message, type = "normal") {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `model-info ${type}`;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Animation subtile des mains
            ['left', 'right'].forEach(side => {
                const hand = currentHands[side];
                if (hand) {
                    hand.rotation.y += Math.sin(time * 0.5 + (side === 'left' ? 0 : Math.PI)) * 0.001;
                    hand.position.y += Math.sin(time * 0.8 + (side === 'left' ? 0 : Math.PI)) * 0.0005;
                }
            });
            
            // Mettre √† jour les mixers d'animation
            if (mixer) {
                mixer.update(delta);
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialisation
        init();
        
        // Message de bienvenue
        setTimeout(() => {
            updateStatus("üöÄ Syst√®me LSQ Pro pr√™t - Chargez vos mains articul√©es!", "loading");
        }, 1500);
    </script>
</body>
</html>
