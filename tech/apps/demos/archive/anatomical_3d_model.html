<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mod√®le 3D Anatomique - Langue des Signes</title>
    <script src="../../../assets/vendor/three.min.js"></script>
    <script src="../../../assets/vendor/dat.gui.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            margin: 10px;
        }

        .control-group label {
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .control-group input, .control-group select {
            padding: 5px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.9);
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button.record {
            background: #f44336;
        }

        button.record:hover {
            background: #da190b;
        }

        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 250px;
        }

        .gesture-library {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 200px;
        }

        .gesture-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .gesture-item:hover {
            background: rgba(255,255,255,0.2);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2em;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            #ui-panel, #controls, #info, .gesture-library {
                position: relative;
                margin: 10px;
                max-width: none;
            }
            
            #controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">Chargement du mod√®le anatomique 3D...</div>
        
        <div id="ui-panel">
            <h3>ü§ñ Mod√®le Anatomique 3D</h3>
            <p><strong>Pr√©cision :</strong> Toutes les phalanges mod√©lis√©es</p>
            <p><strong>Articulations :</strong> 27 par main (54 total)</p>
            <p><strong>Degr√©s de libert√© :</strong> 3 par articulation</p>
            <hr>
            <div id="joint-counter">
                <strong>Articulations actives :</strong> <span id="active-joints">0</span>/54
            </div>
        </div>

        <div id="info">
            <h4>üìä √âtat Actuel</h4>
            <p id="current-gesture">Position neutre</p>
            <p id="hand-angles">Angles des mains : 0¬∞, 0¬∞</p>
            <p id="finger-state">Doigts : Position naturelle</p>
        </div>

        <div class="gesture-library">
            <h4>ü§ü Biblioth√®que Gestes</h4>
            <div class="gesture-item" onclick="loadGesture('neutral')">ü§ö Position neutre</div>
            <div class="gesture-item" onclick="loadGesture('point')">üëâ Pointer (‚àöd·πõ≈õ)</div>
            <div class="gesture-item" onclick="loadGesture('cup')">ü§≤ Coupe (‚àö≈õru)</div>
            <div class="gesture-item" onclick="loadGesture('speak')">üó£Ô∏è Parler (‚àövac)</div>
            <div class="gesture-item" onclick="loadGesture('think')">ü§î Penser (‚àöman)</div>
            <div class="gesture-item" onclick="loadGesture('pray')">üôè Pri√®re (‚àöyuj)</div>
            <div class="gesture-item" onclick="loadGesture('grab')">‚úä Saisir (‚àögrah)</div>
            <div class="gesture-item" onclick="loadGesture('peace')">‚úåÔ∏è Paix (‚àörak·π£)</div>
            <div class="gesture-item" onclick="loadGesture('ok')">üëå OK (‚àök·πõ)</div>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>Rotation Mod√®le</label>
                <input type="range" id="rotation-x" min="-180" max="180" value="0" onchange="updateRotation()">
                <input type="range" id="rotation-y" min="-180" max="180" value="0" onchange="updateRotation()">
            </div>

            <div class="control-group">
                <label>Position Mains</label>
                <select id="hand-position" onchange="updateHandPosition()">
                    <option value="neutral">Neutre</option>
                    <option value="raised">Lev√©es</option>
                    <option value="forward">Vers l'avant</option>
                    <option value="sides">Sur les c√¥t√©s</option>
                    <option value="chest">Poitrine</option>
                </select>
            </div>

            <div class="control-group">
                <label>Vitesse Animation</label>
                <input type="range" id="animation-speed" min="0.1" max="3" step="0.1" value="1" onchange="updateAnimationSpeed()">
            </div>

            <div class="control-group">
                <button onclick="playGestureSequence()">‚ñ∂Ô∏è Jouer S√©quence</button>
                <button onclick="recordGesture()" class="record">‚è∫Ô∏è Enregistrer</button>
                <button onclick="resetModel()">üîÑ Reset</button>
                <button onclick="exportModel()">üíæ Exporter</button>
            </div>
        </div>
    </div>

    <script>
        // Variables globales Three.js
        let scene, camera, renderer, humanModel;
        let handLeft, handRight;
        let fingers = {
            left: {},
            right: {}
        };
        let animationMixer;
        let currentGesture = 'neutral';
        let isAnimating = false;

        // Configuration anatomique
        const HAND_CONFIG = {
            fingers: ['thumb', 'index', 'middle', 'ring', 'pinky'],
            joints: ['metacarpal', 'proximal', 'middle', 'distal'],
            thumbJoints: ['metacarpal', 'proximal', 'distal'] // Le pouce n'a que 3 phalanges
        };

        // Initialisation de la sc√®ne 3D
        function initThreeJS() {
            // Sc√®ne
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a5298);

            // Cam√©ra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // √âclairage
            setupLighting();

            // Cr√©ation du mod√®le humain
            createHumanModel();
            
            // Ajouter le mod√®le √† la sc√®ne
            scene.add(humanModel);
            console.log('üé≠ Mod√®le anatomique ajout√© √† la sc√®ne');

            // Contr√¥les de cam√©ra
            setupCameraControls();

            // Animation
            animate();

            // Masquer le loading
            document.getElementById('loading').style.display = 'none';
        }

        function setupLighting() {
            // Lumi√®re ambiante
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Lumi√®re directionnelle
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Lumi√®re spot pour les mains
            const spotLight = new THREE.SpotLight(0xffffff, 0.5);
            spotLight.position.set(0, 2, 2);
            spotLight.target.position.set(0, 1.2, 0);
            scene.add(spotLight);
            scene.add(spotLight.target);
        }

        function createHumanModel() {
            console.log('üèóÔ∏è Cr√©ation du mod√®le anatomique complet...');
            
            // Groupe principal pour le mod√®le humain
            humanModel = new THREE.Group();

            // Mod√®le anatomique complet du haut du corps
            createDetailedTorso();
            createDetailedShoulders();
            createDetailedArms();
            createDetailedHands();
            createDetailedHands();

            scene.add(humanModel);
        }

        // Couleurs anatomiques distinctes
        const ANATOMY_COLORS = {
            torso: 0xf4c2a1,        // Beige clair pour le torse
            shoulders: 0xe8b088,     // Beige plus fonc√© pour les √©paules
            upperArm: 0xd49c6e,     // Brun clair pour le haut du bras
            forearm: 0xc8935a,      // Brun moyen pour l'avant-bras
            hands: 0xb8824a,        // Brun plus fonc√© pour les mains
            joints: 0x8b4513        // Brun fonc√© pour les articulations
        };

        function createDetailedTorso() {
            console.log('ü´Å Cr√©ation du torse d√©taill√©...');
            
            // Torse principal (de la taille au cou)
            const torsoGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const torsoMaterial = new THREE.MeshPhongMaterial({ 
                color: ANATOMY_COLORS.torso,
                transparent: true,
                opacity: 0.9
            });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.set(0, 0.6, 0);
            torso.name = 'torso';
            humanModel.add(torso);

            // Cage thoracique (indication visuelle)
            const ribGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.8, 8);
            const ribMaterial = new THREE.MeshPhongMaterial({ 
                color: ANATOMY_COLORS.torso,
                wireframe: true,
                opacity: 0.3,
                transparent: true
            });
            const ribCage = new THREE.Mesh(ribGeometry, ribMaterial);
            ribCage.position.set(0, 0.8, 0);
            ribCage.name = 'ribcage';
            humanModel.add(ribCage);

            // Cou
            const neckGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.3);
            const neckMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.torso });
            const neck = new THREE.Mesh(neckGeometry, neckMaterial);
            neck.position.set(0, 1.35, 0);
            neck.name = 'neck';
            humanModel.add(neck);

            console.log('‚úÖ Torse cr√©√© avec succ√®s');
        }

        function createDetailedShoulders() {
            console.log('ü´∏ Cr√©ation des √©paules d√©taill√©es...');
            
            // √âpaule gauche
            const leftShoulderGeometry = new THREE.SphereGeometry(0.22, 16, 16);
            const shoulderMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.shoulders });
            const leftShoulder = new THREE.Mesh(leftShoulderGeometry, shoulderMaterial);
            leftShoulder.position.set(-0.5, 1.1, 0);
            leftShoulder.name = 'leftShoulder';
            humanModel.add(leftShoulder);

            // √âpaule droite
            const rightShoulder = new THREE.Mesh(leftShoulderGeometry, shoulderMaterial);
            rightShoulder.position.set(0.5, 1.1, 0);
            rightShoulder.name = 'rightShoulder';
            humanModel.add(rightShoulder);

            // Clavicules
            const clavicleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4);
            const clavicleMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.shoulders });
            
            const leftClavicle = new THREE.Mesh(clavicleGeometry, clavicleMaterial);
            leftClavicle.rotation.z = Math.PI / 2;
            leftClavicle.position.set(-0.2, 1.25, 0);
            leftClavicle.name = 'leftClavicle';
            humanModel.add(leftClavicle);

            const rightClavicle = new THREE.Mesh(clavicleGeometry, clavicleMaterial);
            rightClavicle.rotation.z = Math.PI / 2;
            rightClavicle.position.set(0.2, 1.25, 0);
            rightClavicle.name = 'rightClavicle';
            humanModel.add(rightClavicle);

            console.log('‚úÖ √âpaules cr√©√©es avec succ√®s');
        }

        function createDetailedArms() {
            console.log('üí™ Cr√©ation des bras d√©taill√©s...');
            
            // BRAS GAUCHE
            // Haut du bras gauche (hum√©rus)
            const upperArmGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.6);
            const upperArmMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.upperArm });
            
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
            leftUpperArm.position.set(-0.5, 0.7, 0);
            leftUpperArm.name = 'leftUpperArm';
            humanModel.add(leftUpperArm);

            // Coude gauche
            const elbowGeometry = new THREE.SphereGeometry(0.1, 12, 12);
            const elbowMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.joints });
            
            const leftElbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
            leftElbow.position.set(-0.5, 0.4, 0);
            leftElbow.name = 'leftElbow';
            humanModel.add(leftElbow);

            // Avant-bras gauche (radius et ulna)
            const forearmGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.5);
            const forearmMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.forearm });
            
            const leftForearm = new THREE.Mesh(forearmGeometry, forearmMaterial);
            leftForearm.position.set(-0.5, 0.1, 0);
            leftForearm.name = 'leftForearm';
            humanModel.add(leftForearm);

            // Poignet gauche
            const wristGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.1);
            const wristMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.joints });
            
            const leftWrist = new THREE.Mesh(wristGeometry, wristMaterial);
            leftWrist.position.set(-0.5, -0.2, 0);
            leftWrist.name = 'leftWrist';
            humanModel.add(leftWrist);

            // BRAS DROIT (sym√©trique)
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
            rightUpperArm.position.set(0.5, 0.7, 0);
            rightUpperArm.name = 'rightUpperArm';
            humanModel.add(rightUpperArm);

            const rightElbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
            rightElbow.position.set(0.5, 0.4, 0);
            rightElbow.name = 'rightElbow';
            humanModel.add(rightElbow);

            const rightForearm = new THREE.Mesh(forearmGeometry, forearmMaterial);
            rightForearm.position.set(0.5, 0.1, 0);
            rightForearm.name = 'rightForearm';
            humanModel.add(rightForearm);

            const rightWrist = new THREE.Mesh(wristGeometry, wristMaterial);
            rightWrist.position.set(0.5, -0.2, 0);
            rightWrist.name = 'rightWrist';
            humanModel.add(rightWrist);

            console.log('‚úÖ Bras cr√©√©s avec succ√®s');
        }

        function createDetailedHands() {
            console.log('üñêÔ∏è Cr√©ation des mains d√©taill√©es...');
            
            // MAIN GAUCHE
            createSingleHand(-0.5, -0.35, 'left');
            
            // MAIN DROITE
            createSingleHand(0.5, -0.35, 'right');
            
            console.log('‚úÖ Mains cr√©√©es avec succ√®s');
        }

        function createSingleHand(x, y, side) {
            const handGroup = new THREE.Group();
            handGroup.name = `${side}Hand`;

            // Paume
            const palmGeometry = new THREE.BoxGeometry(0.12, 0.18, 0.06);
            const palmMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.hands });
            const palm = new THREE.Mesh(palmGeometry, palmMaterial);
            palm.position.set(0, 0, 0);
            palm.name = `${side}Palm`;
            handGroup.add(palm);

            // Doigts d√©taill√©s
            const fingerNames = ['thumb', 'index', 'middle', 'ring', 'pinky'];
            const fingerPositions = [
                { x: -0.08, y: 0.05, z: 0.03, segments: 2 },  // Pouce
                { x: -0.05, y: 0.12, z: 0, segments: 3 },     // Index
                { x: -0.015, y: 0.14, z: 0, segments: 3 },    // Majeur
                { x: 0.02, y: 0.13, z: 0, segments: 3 },      // Annulaire
                { x: 0.05, y: 0.1, z: 0, segments: 3 }        // Auriculaire
            ];

            fingerPositions.forEach((pos, index) => {
                const fingerName = fingerNames[index];
                createFinger(handGroup, pos.x, pos.y, pos.z, pos.segments, `${side}${fingerName}`);
            });

            // Positionnement de la main
            handGroup.position.set(x, y, 0);
            humanModel.add(handGroup);
        }

        function createFinger(parent, startX, startY, startZ, segments, name) {
            const fingerGroup = new THREE.Group();
            fingerGroup.name = name;

            const segmentLength = 0.04;
            const segmentRadius = 0.015;

            for (let i = 0; i < segments; i++) {
                // Phalange
                const phalangeGeometry = new THREE.CylinderGeometry(
                    segmentRadius * (1 - i * 0.1), 
                    segmentRadius * (1 - i * 0.1), 
                    segmentLength
                );
                const phalangeMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.hands });
                const phalange = new THREE.Mesh(phalangeGeometry, phalangeMaterial);
                
                phalange.position.set(
                    startX, 
                    startY + (i * segmentLength * 1.2), 
                    startZ
                );
                phalange.name = `${name}_phalange_${i}`;
                fingerGroup.add(phalange);

                // Articulation
                if (i < segments - 1) {
                    const jointGeometry = new THREE.SphereGeometry(segmentRadius * 0.8, 8, 8);
                    const jointMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.joints });
                    const joint = new THREE.Mesh(jointGeometry, jointMaterial);
                    
                    joint.position.set(
                        startX, 
                        startY + ((i + 0.5) * segmentLength * 1.2), 
                        startZ
                    );
                    joint.name = `${name}_joint_${i}`;
                    fingerGroup.add(joint);
                }
            }

            parent.add(fingerGroup);
        }

        function createArms() {
            // Bras gauche
            const leftArmGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.6, 8);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
            leftArm.position.set(-0.5, 1.4, 0);
            leftArm.rotation.z = Math.PI / 6;
            humanModel.add(leftArm);

            // Bras droit
            const rightArm = new THREE.Mesh(leftArmGeometry, armMaterial);
            rightArm.position.set(0.5, 1.4, 0);
            rightArm.rotation.z = -Math.PI / 6;
            humanModel.add(rightArm);

            // Avant-bras
            const forearmGeometry = new THREE.CylinderGeometry(0.06, 0.05, 0.5, 8);
            const leftForearm = new THREE.Mesh(forearmGeometry, armMaterial);
            leftForearm.position.set(-0.7, 1, 0.2);
            leftForearm.rotation.z = Math.PI / 4;
            humanModel.add(leftForearm);

            const rightForearm = new THREE.Mesh(forearmGeometry, armMaterial);
            rightForearm.position.set(0.7, 1, 0.2);
            rightForearm.rotation.z = -Math.PI / 4;
            humanModel.add(rightForearm);
        }

        function createDetailedHands() {
            // Main gauche
            handLeft = createDetailedHand('left');
            handLeft.position.set(-0.9, 0.8, 0.4);
            humanModel.add(handLeft);

            // Main droite
            handRight = createDetailedHand('right');
            handRight.position.set(0.9, 0.8, 0.4);
            humanModel.add(handRight);
        }

        function createDetailedHand(side) {
            const hand = new THREE.Group();
            const handMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });

            // Paume
            const palmGeometry = new THREE.BoxGeometry(0.12, 0.02, 0.16);
            const palm = new THREE.Mesh(palmGeometry, handMaterial);
            hand.add(palm);

            // Cr√©er les doigts avec toutes les phalanges
            fingers[side] = {};
            HAND_CONFIG.fingers.forEach((fingerName, fingerIndex) => {
                fingers[side][fingerName] = createDetailedFinger(fingerName, fingerIndex, side, handMaterial);
                hand.add(fingers[side][fingerName].group);
            });

            return hand;
        }

        function createDetailedFinger(fingerName, fingerIndex, side, material) {
            const finger = {
                group: new THREE.Group(),
                joints: {},
                segments: {}
            };

            // Configuration sp√©ciale pour le pouce
            const joints = fingerName === 'thumb' ? HAND_CONFIG.thumbJoints : HAND_CONFIG.joints;
            const isThumb = fingerName === 'thumb';

            // Position de base du doigt
            let baseX = (fingerIndex - 2) * 0.025;
            let baseY = 0.01;
            let baseZ = isThumb ? -0.04 : 0.08;

            if (isThumb) {
                baseX = side === 'left' ? 0.06 : -0.06;
            }

            let currentY = baseY;

            joints.forEach((jointName, jointIndex) => {
                // Taille des segments selon la phalange
                let segmentLength = 0.025;
                let segmentRadius = 0.008;

                if (jointName === 'metacarpal') {
                    segmentLength = 0.035;
                    segmentRadius = 0.01;
                } else if (jointName === 'proximal') {
                    segmentLength = 0.03;
                } else if (jointName === 'middle') {
                    segmentLength = 0.025;
                    segmentRadius = 0.007;
                } else if (jointName === 'distal') {
                    segmentLength = 0.02;
                    segmentRadius = 0.006;
                }

                // Cr√©er le segment de phalange avec CylinderGeometry (CapsuleGeometry n'existe pas en r128)
                const segmentGeometry = new THREE.CylinderGeometry(segmentRadius, segmentRadius, segmentLength, 8);
                const segment = new THREE.Mesh(segmentGeometry, material);

                // Position du segment
                segment.position.set(baseX, currentY + segmentLength/2, baseZ);
                
                // Cr√©er le groupe d'articulation
                const joint = new THREE.Group();
                joint.position.set(baseX, currentY, baseZ);
                joint.add(segment);

                // Stocker la r√©f√©rence
                finger.joints[jointName] = joint;
                finger.segments[jointName] = segment;

                // Ajouter au groupe du doigt
                if (jointIndex === 0) {
                    finger.group.add(joint);
                } else {
                    // Attacher au joint pr√©c√©dent
                    const prevJointName = joints[jointIndex - 1];
                    finger.joints[prevJointName].add(joint);
                    // Ajuster la position relative
                    joint.position.y = segmentLength;
                    joint.position.x = 0;
                    joint.position.z = 0;
                }

                currentY += segmentLength;
            });

            // Position initiale des doigts
            if (isThumb) {
                finger.group.rotation.y = side === 'left' ? -Math.PI/3 : Math.PI/3;
                finger.group.rotation.z = Math.PI/6;
            } else {
                finger.group.rotation.x = -Math.PI/12; // L√©g√®re courbure naturelle
            }

            return finger;
        }

        function setupCameraControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };

                const deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        toRadians(deltaMove.y * 1),
                        toRadians(deltaMove.x * 1),
                        0,
                        'XYZ'
                    ));

                humanModel.quaternion.multiplyQuaternions(deltaRotationQuaternion, humanModel.quaternion);

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Zoom avec la molette
            renderer.domElement.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.1;
                camera.position.z += e.deltaY * zoomSpeed * 0.01;
                camera.position.z = Math.max(1, Math.min(10, camera.position.z));
            });
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Mise √† jour du compteur d'articulations
            updateJointCounter();

            // Mise √† jour de l'info
            updateInfo();

            renderer.render(scene, camera);
        }

        function updateJointCounter() {
            let activeJoints = 0;
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const joints = fingerName === 'thumb' ? HAND_CONFIG.thumbJoints : HAND_CONFIG.joints;
                        joints.forEach(jointName => {
                            if (fingers[side][fingerName].joints[jointName]) {
                                const rotation = fingers[side][fingerName].joints[jointName].rotation;
                                if (Math.abs(rotation.x) > 0.01 || Math.abs(rotation.y) > 0.01 || Math.abs(rotation.z) > 0.01) {
                                    activeJoints++;
                                }
                            }
                        });
                    }
                });
            });
            document.getElementById('active-joints').textContent = activeJoints;
        }

        function updateInfo() {
            document.getElementById('current-gesture').textContent = `Geste actuel: ${currentGesture}`;
            
            if (handLeft && handRight) {
                const leftAngle = Math.round(handLeft.rotation.y * 180 / Math.PI);
                const rightAngle = Math.round(handRight.rotation.y * 180 / Math.PI);
                document.getElementById('hand-angles').textContent = `Angles des mains: ${leftAngle}¬∞, ${rightAngle}¬∞`;
            }
        }

        // Fonctions de contr√¥le des gestes
        function loadGesture(gestureName) {
            currentGesture = gestureName;
            resetAllFingers();

            switch(gestureName) {
                case 'neutral':
                    setNeutralPose();
                    break;
                case 'point':
                    setPointingGesture();
                    break;
                case 'cup':
                    setCuppingGesture();
                    break;
                case 'speak':
                    setSpeakingGesture();
                    break;
                case 'think':
                    setThinkingGesture();
                    break;
                case 'pray':
                    setPrayerGesture();
                    break;
                case 'grab':
                    setGrabbingGesture();
                    break;
                case 'peace':
                    setPeaceGesture();
                    break;
                case 'ok':
                    setOKGesture();
                    break;
            }
        }

        function resetAllFingers() {
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const joints = fingerName === 'thumb' ? HAND_CONFIG.thumbJoints : HAND_CONFIG.joints;
                        joints.forEach(jointName => {
                            if (fingers[side][fingerName].joints[jointName]) {
                                fingers[side][fingerName].joints[jointName].rotation.set(0, 0, 0);
                            }
                        });
                    }
                });
            });
        }

        function setNeutralPose() {
            // Position naturelle d√©tendue
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const finger = fingers[side][fingerName];
                        if (fingerName === 'thumb') {
                            finger.joints.metacarpal.rotation.x = -0.2;
                            finger.joints.proximal.rotation.x = -0.1;
                        } else {
                            finger.joints.proximal.rotation.x = -0.15;
                            finger.joints.middle.rotation.x = -0.1;
                            finger.joints.distal.rotation.x = -0.05;
                        }
                    }
                });
            });
        }

        function setPointingGesture() {
            // Index tendu, autres doigts ferm√©s (pour ‚àöd·πõ≈õ - voir)
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const finger = fingers[side][fingerName];
                        if (fingerName === 'index') {
                            // Index tendu
                            finger.joints.proximal.rotation.x = 0;
                            finger.joints.middle.rotation.x = 0;
                            finger.joints.distal.rotation.x = 0;
                        } else {
                            // Autres doigts ferm√©s
                            if (fingerName === 'thumb') {
                                finger.joints.metacarpal.rotation.x = -0.8;
                                finger.joints.proximal.rotation.x = -0.6;
                            } else {
                                finger.joints.proximal.rotation.x = -1.2;
                                finger.joints.middle.rotation.x = -1.0;
                                finger.joints.distal.rotation.x = -0.8;
                            }
                        }
                    }
                });
            });
        }

        function setCuppingGesture() {
            // Mains en coupe (pour ‚àö≈õru - entendre)
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const finger = fingers[side][fingerName];
                        if (fingerName === 'thumb') {
                            finger.joints.metacarpal.rotation.x = -0.4;
                            finger.joints.proximal.rotation.x = -0.3;
                        } else {
                            finger.joints.proximal.rotation.x = -0.6;
                            finger.joints.middle.rotation.x = -0.4;
                            finger.joints.distal.rotation.x = -0.2;
                        }
                    }
                });
            });
        }

        function setSpeakingGesture() {
            // Main ouverte pr√®s de la bouche (pour ‚àövac - parler)
            setNeutralPose();
            if (handRight) {
                handRight.position.set(0.3, 1.6, 0.6); // Pr√®s de la bouche
            }
        }

        function setThinkingGesture() {
            // Index √† la tempe (pour ‚àöman - penser)
            setPointingGesture();
            if (handRight) {
                handRight.position.set(0.2, 1.8, 0.3); // √Ä la tempe
                handRight.rotation.y = -Math.PI/4;
            }
        }

        function setPrayerGesture() {
            // Paumes jointes (pour ‚àöyuj - unir)
            setNeutralPose();
            if (handLeft && handRight) {
                handLeft.position.set(-0.1, 1.4, 0.4);
                handRight.position.set(0.1, 1.4, 0.4);
                handLeft.rotation.y = Math.PI/4;
                handRight.rotation.y = -Math.PI/4;
            }
        }

        function setGrabbingGesture() {
            // Poing ferm√© (pour ‚àögrah - saisir)
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const finger = fingers[side][fingerName];
                        if (fingerName === 'thumb') {
                            finger.joints.metacarpal.rotation.x = -1.0;
                            finger.joints.proximal.rotation.x = -0.8;
                        } else {
                            finger.joints.proximal.rotation.x = -1.4;
                            finger.joints.middle.rotation.x = -1.2;
                            finger.joints.distal.rotation.x = -1.0;
                        }
                    }
                });
            });
        }

        function setPeaceGesture() {
            // Deux doigts en V
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const finger = fingers[side][fingerName];
                        if (fingerName === 'index' || fingerName === 'middle') {
                            // Index et majeur tendus
                            finger.joints.proximal.rotation.x = 0;
                            finger.joints.middle.rotation.x = 0;
                            finger.joints.distal.rotation.x = 0;
                            // √âcartement en V
                            if (fingerName === 'index') {
                                finger.group.rotation.z = -0.3;
                            } else {
                                finger.group.rotation.z = 0.3;
                            }
                        } else {
                            // Autres doigts ferm√©s
                            if (fingerName === 'thumb') {
                                finger.joints.metacarpal.rotation.x = -0.8;
                                finger.joints.proximal.rotation.x = -0.6;
                            } else {
                                finger.joints.proximal.rotation.x = -1.2;
                                finger.joints.middle.rotation.x = -1.0;
                                finger.joints.distal.rotation.x = -0.8;
                            }
                        }
                    }
                });
            });
        }

        function setOKGesture() {
            // Pouce et index en cercle (pour ‚àök·πõ - faire/perfection)
            ['left', 'right'].forEach(side => {
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        const finger = fingers[side][fingerName];
                        if (fingerName === 'thumb') {
                            finger.joints.metacarpal.rotation.x = -0.5;
                            finger.joints.proximal.rotation.x = -0.8;
                        } else if (fingerName === 'index') {
                            finger.joints.proximal.rotation.x = -0.8;
                            finger.joints.middle.rotation.x = -0.6;
                            finger.joints.distal.rotation.x = -0.4;
                        } else {
                            // Autres doigts tendus
                            finger.joints.proximal.rotation.x = 0;
                            finger.joints.middle.rotation.x = 0;
                            finger.joints.distal.rotation.x = 0;
                        }
                    }
                });
            });
        }

        // Fonctions de contr√¥le de l'interface
        function updateRotation() {
            const rotX = document.getElementById('rotation-x').value;
            const rotY = document.getElementById('rotation-y').value;
            humanModel.rotation.x = toRadians(rotX);
            humanModel.rotation.y = toRadians(rotY);
        }

        function updateHandPosition() {
            const position = document.getElementById('hand-position').value;
            
            switch(position) {
                case 'neutral':
                    handLeft.position.set(-0.9, 0.8, 0.4);
                    handRight.position.set(0.9, 0.8, 0.4);
                    break;
                case 'raised':
                    handLeft.position.set(-0.7, 1.6, 0.2);
                    handRight.position.set(0.7, 1.6, 0.2);
                    break;
                case 'forward':
                    handLeft.position.set(-0.5, 1.2, 0.8);
                    handRight.position.set(0.5, 1.2, 0.8);
                    break;
                case 'sides':
                    handLeft.position.set(-1.2, 1.0, 0);
                    handRight.position.set(1.2, 1.0, 0);
                    break;
                case 'chest':
                    handLeft.position.set(-0.3, 1.4, 0.4);
                    handRight.position.set(0.3, 1.4, 0.4);
                    break;
            }
        }

        function updateAnimationSpeed() {
            const speed = document.getElementById('animation-speed').value;
            // Impl√©menter la vitesse d'animation
        }

        function playGestureSequence() {
            if (isAnimating) return;
            
            isAnimating = true;
            const gestures = ['neutral', 'point', 'cup', 'speak', 'think', 'pray'];
            let currentIndex = 0;
            
            const playNext = () => {
                if (currentIndex < gestures.length) {
                    loadGesture(gestures[currentIndex]);
                    currentIndex++;
                    setTimeout(playNext, 2000);
                } else {
                    isAnimating = false;
                    loadGesture('neutral');
                }
            };
            
            playNext();
        }

        function recordGesture() {
            const gestureData = {
                timestamp: new Date().toISOString(),
                gesture: currentGesture,
                handPositions: {
                    left: {
                        position: handLeft.position.toArray(),
                        rotation: handLeft.rotation.toArray()
                    },
                    right: {
                        position: handRight.position.toArray(),
                        rotation: handRight.rotation.toArray()
                    }
                },
                fingerPositions: {}
            };

            ['left', 'right'].forEach(side => {
                gestureData.fingerPositions[side] = {};
                HAND_CONFIG.fingers.forEach(fingerName => {
                    if (fingers[side][fingerName]) {
                        gestureData.fingerPositions[side][fingerName] = {};
                        const joints = fingerName === 'thumb' ? HAND_CONFIG.thumbJoints : HAND_CONFIG.joints;
                        joints.forEach(jointName => {
                            if (fingers[side][fingerName].joints[jointName]) {
                                gestureData.fingerPositions[side][fingerName][jointName] = 
                                    fingers[side][fingerName].joints[jointName].rotation.toArray();
                            }
                        });
                    }
                });
            });

            // Exporter en JSON
            const blob = new Blob([JSON.stringify(gestureData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gesture_${currentGesture}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            alert(`Geste "${currentGesture}" enregistr√© avec succ√®s!`);
        }

        function resetModel() {
            loadGesture('neutral');
            humanModel.rotation.set(0, 0, 0);
            camera.position.set(0, 1.6, 3);
            document.getElementById('rotation-x').value = 0;
            document.getElementById('rotation-y').value = 0;
            document.getElementById('hand-position').value = 'neutral';
            updateHandPosition();
        }

        function exportModel() {
            // Exporter le mod√®le complet en format .obj ou .gltf
            const exporter = new THREE.OBJExporter();
            const result = exporter.parse(humanModel);
            
            const blob = new Blob([result], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `human_model_3d_${Date.now()}.obj`;
            a.click();
            URL.revokeObjectURL(url);

            alert('Mod√®le 3D export√© avec succ√®s!');
        }

        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialisation au chargement avec v√©rification des d√©pendances
        window.addEventListener('load', () => {
            console.log('üöÄ Page charg√©e, v√©rification des d√©pendances...');
            
            // V√©rifier si Three.js est charg√©
            if (typeof THREE === 'undefined') {
                console.error('‚ùå Three.js non charg√©!');
                document.getElementById('loading').innerHTML = '‚ùå Erreur: Three.js non trouv√©';
                return;
            }
            console.log('‚úÖ Three.js charg√©');
            
            // V√©rifier si dat.GUI est charg√©
            if (typeof dat === 'undefined') {
                console.error('‚ùå dat.GUI non charg√©!');
                document.getElementById('loading').innerHTML = '‚ùå Erreur: dat.GUI non trouv√©';
                return;
            }
            console.log('‚úÖ dat.GUI charg√©');
            
            try {
                console.log('üéØ Initialisation de Three.js...');
                initThreeJS();
                console.log('‚úÖ Three.js initialis√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'initialisation:', error);
                document.getElementById('loading').innerHTML = '‚ùå Erreur: ' + error.message;
            }
        });
    </script>
</body>
</html>
