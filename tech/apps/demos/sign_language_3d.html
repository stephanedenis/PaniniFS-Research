<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ü Syst√®me de Langue des Signes 3D - ASL/LSQ</title>
    <script src="../../assets/vendor/three.min.js"></script>
    <script src="../../assets/vendor/dat.gui.min.js"></script>
    <script>
        // Configuration de base three.js
        let scene, camera, renderer;

        function init() {
            // Sc√®ne
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // Cam√©ra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lumi√®re
            const light = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 0).normalize();
            scene.add(directionalLight);

            // Contr√¥les
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;

            // Animation
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }

        window.onload = init;
    </script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-top: 20px;
        }

        #info {
            text-align: center;
            margin: 10px 0;
        }

        #viewer {
            width: 100%;
            height: 80vh;
            display: block;
            margin: 0 auto;
            background: #fff;
            border: 1px solid #ccc;
        }

        @media (max-width: 600px) {
            #info {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <h1>ü§ü Syst√®me de Langue des Signes 3D - ASL/LSQ</h1>
    <div id="info">
        <p>Utilisez la souris pour faire pivoter et zoomer.</p>
    </div>
    <div id="viewer"></div>

    <script>
        // Variables globales
        let scene, camera, renderer, humanModel;
        let currentLanguage = 'ASL';
        let currentGesture = 'neutral';
        let animationSpeed = 1.0;
        let torso, leftShoulder, rightShoulder, leftArm, rightArm, leftHand, rightHand;

        // Couleurs anatomiques r√©alistes
        const ANATOMY_COLORS = {
            torso: 0xf4c2a1,        // Chair
            shoulders: 0xe8b088,     // Chair plus fonc√©e
            upperArm: 0xd49c6e,     // Bras
            forearm: 0xc8935a,      // Avant-bras
            hands: 0xb8824a,        // Mains
            joints: 0x8b4513,       // Articulations
            face: 0xfdbcb4          // Visage
        };

        // Initialisation au chargement
        window.addEventListener('load', () => {
            console.log('üöÄ Initialisation du syst√®me de langue des signes...');
            
            // V√©rification des d√©pendances
            if (typeof THREE === 'undefined') {
                console.error('‚ùå Three.js non charg√©!');
                document.getElementById('loading').innerHTML = '‚ùå Erreur: Three.js non trouv√©';
                return;
            }
            
            if (typeof dat === 'undefined') {
                console.error('‚ùå dat.GUI non charg√©!');
                document.getElementById('loading').innerHTML = '‚ùå Erreur: dat.GUI non trouv√©';
                return;
            }
            
            try {
                initializeInterface();
                initThreeJS();
                console.log('‚úÖ Syst√®me initialis√© avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'initialisation:', error);
                document.getElementById('loading').innerHTML = '‚ùå Erreur: ' + error.message;
            }
        });

        function initializeInterface() {
            // G√©n√©rer l'alphabet
            const alphabetGrid = document.getElementById('alphabet-grid');
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const btn = document.createElement('div');
                btn.className = 'letter-btn';
                btn.textContent = letter;
                btn.onclick = () => showLetter(letter);
                alphabetGrid.appendChild(btn);
            }

            // G√©n√©rer les nombres
            const numberGrid = document.getElementById('number-grid');
            for (let i = 0; i <= 9; i++) {
                const btn = document.createElement('div');
                btn.className = 'letter-btn';
                btn.textContent = i;
                btn.onclick = () => showNumber(i);
                numberGrid.appendChild(btn);
            }

            console.log('‚úÖ Interface initialis√©e');
        }

        function initThreeJS() {
            console.log('üéØ Initialisation de Three.js...');
            
            // R√©cup√©rer le conteneur 3D
            const container = document.getElementById('viewer-3d');
            const rect = container.getBoundingClientRect();

            // Sc√®ne
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Cam√©ra
            camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
            camera.position.set(0, 1.6, 4);

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true
            });
            renderer.setSize(rect.width, rect.height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Ajouter le canvas au conteneur 3D
            container.appendChild(renderer.domElement);

            // √âclairage
            setupLighting();

            // Cr√©ation du mod√®le humain avec torse fixe
            createRealisticHumanModel();

            // Contr√¥les de cam√©ra
            setupCameraControls();

            // Animation
            animate();

            // Masquer le loading
            document.getElementById('loading').classList.add('hidden');
            
            console.log('‚úÖ Three.js initialis√©');
        }

        function setupLighting() {
            // Lumi√®re ambiante douce
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Lumi√®re directionnelle principale
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Lumi√®re de remplissage
            const fillLight = new THREE.DirectionalLight(0x8cc8ff, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            // Lumi√®re spot pour les mains
            const spotLight = new THREE.SpotLight(0xffffff, 0.4);
            spotLight.position.set(0, 3, 2);
            spotLight.target.position.set(0, 1.2, 0);
            scene.add(spotLight);
            scene.add(spotLight.target);
        }

        function createRealisticHumanModel() {
            console.log('üèóÔ∏è Cr√©ation du mod√®le anatomique r√©aliste...');
            
            humanModel = new THREE.Group();
            humanModel.name = 'humanModel';

            // TORSE FIXE (immobile)
            createFixedTorso();
            
            // VISAGE (pour lecture labiale)
            createFace();
            
            // BRAS MOBILES avec mains attach√©es
            createMobileArms();

            // Ajouter √† la sc√®ne
            scene.add(humanModel);
            
            console.log('‚úÖ Mod√®le anatomique cr√©√©');
        }

        function createFixedTorso() {
            // Torse principal - FIXE
            const torsoGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const torsoMaterial = new THREE.MeshPhongMaterial({ 
                color: ANATOMY_COLORS.torso,
                transparent: true,
                opacity: 0.9
            });
            torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.set(0, 0.6, 0);
            torso.name = 'torso';
            torso.userData.fixed = true; // Marquer comme fixe
            humanModel.add(torso);

            // Cou
            const neckGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.3);
            const neckMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.torso });
            const neck = new THREE.Mesh(neckGeometry, neckMaterial);
            neck.position.set(0, 1.35, 0);
            neck.name = 'neck';
            neck.userData.fixed = true;
            humanModel.add(neck);

            console.log('‚úÖ Torse fixe cr√©√©');
        }

        function createFace() {
            // T√™te pour lecture labiale
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.face });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.7, 0);
            head.name = 'head';
            head.userData.fixed = true;
            humanModel.add(head);

            // Yeux (simples)
            const eyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.75, 0.2);
            head.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.75, 0.2);
            head.add(rightEye);

            // Bouche (pour lecture labiale)
            const mouthGeometry = new THREE.BoxGeometry(0.1, 0.02, 0.02);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0x8b0000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.65, 0.22);
            mouth.name = 'mouth';
            head.add(mouth);

            console.log('‚úÖ Visage cr√©√© pour lecture labiale');
        }

        function createMobileArms() {
            // BRAS GAUCHE MOBILE
            leftArm = createSingleMobileArm(-0.5, 'left');
            humanModel.add(leftArm);
            
            // BRAS DROIT MOBILE  
            rightArm = createSingleMobileArm(0.5, 'right');
            humanModel.add(rightArm);
            
            console.log('‚úÖ Bras mobiles cr√©√©s');
        }

        function createSingleMobileArm(x, side) {
            const armGroup = new THREE.Group();
            armGroup.name = `${side}Arm`;
            armGroup.position.x = x;

            // √âpaule (point d'attache mobile)
            const shoulderGeometry = new THREE.SphereGeometry(0.22, 16, 16);
            const shoulderMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.shoulders });
            const shoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            shoulder.position.set(0, 1.1, 0);
            shoulder.name = `${side}Shoulder`;
            armGroup.add(shoulder);

            // Haut du bras (attach√© √† l'√©paule)
            const upperArmGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.6);
            const upperArmMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.upperArm });
            const upperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
            upperArm.position.set(0, 0.7, 0);
            upperArm.name = `${side}UpperArm`;
            armGroup.add(upperArm);

            // Coude
            const elbowGeometry = new THREE.SphereGeometry(0.1, 12, 12);
            const elbowMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.joints });
            const elbow = new THREE.Mesh(elbowGeometry, elbowMaterial);
            elbow.position.set(0, 0.4, 0);
            elbow.name = `${side}Elbow`;
            armGroup.add(elbow);

            // Avant-bras (attach√© au coude)
            const forearmGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.5);
            const forearmMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.forearm });
            const forearm = new THREE.Mesh(forearmGeometry, forearmMaterial);
            forearm.position.set(0, 0.1, 0);
            forearm.name = `${side}Forearm`;
            armGroup.add(forearm);

            // Poignet
            const wristGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.1);
            const wristMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.joints });
            const wrist = new THREE.Mesh(wristGeometry, wristMaterial);
            wrist.position.set(0, -0.2, 0);
            wrist.name = `${side}Wrist`;
            armGroup.add(wrist);

            // Main attach√©e au bout du bras
            const hand = createRealisticHand(0, -0.35, side);
            armGroup.add(hand);

            return armGroup;
        }

        function createRealisticHand(x, y, side) {
            const handGroup = new THREE.Group();
            handGroup.name = `${side}Hand`;
            handGroup.position.set(x, y, 0);

            // Paume
            const palmGeometry = new THREE.BoxGeometry(0.12, 0.18, 0.06);
            const palmMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.hands });
            const palm = new THREE.Mesh(palmGeometry, palmMaterial);
            palm.name = `${side}Palm`;
            handGroup.add(palm);

            // Doigts r√©alistes
            const fingerConfigs = [
                { name: 'thumb', x: -0.08, y: 0.05, z: 0.03, segments: 2 },
                { name: 'index', x: -0.05, y: 0.12, z: 0, segments: 3 },
                { name: 'middle', x: -0.015, y: 0.14, z: 0, segments: 3 },
                { name: 'ring', x: 0.02, y: 0.13, z: 0, segments: 3 },
                { name: 'pinky', x: 0.05, y: 0.1, z: 0, segments: 3 }
            ];

            fingerConfigs.forEach(config => {
                const finger = createRealisticFinger(config.x, config.y, config.z, config.segments, `${side}${config.name}`);
                handGroup.add(finger);
            });

            return handGroup;
        }

        function createRealisticFinger(startX, startY, startZ, segments, name) {
            const fingerGroup = new THREE.Group();
            fingerGroup.name = name;

            const segmentLength = 0.04;
            const segmentRadius = 0.015;

            for (let i = 0; i < segments; i++) {
                // Phalange
                const phalangeGeometry = new THREE.CylinderGeometry(
                    segmentRadius * (1 - i * 0.1), 
                    segmentRadius * (1 - i * 0.1), 
                    segmentLength
                );
                const phalangeMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.hands });
                const phalange = new THREE.Mesh(phalangeGeometry, phalangeMaterial);
                
                phalange.position.set(
                    startX, 
                    startY + (i * segmentLength * 1.2), 
                    startZ
                );
                phalange.name = `${name}_phalange_${i}`;
                fingerGroup.add(phalange);

                // Articulation
                if (i < segments - 1) {
                    const jointGeometry = new THREE.SphereGeometry(segmentRadius * 0.8, 8, 8);
                    const jointMaterial = new THREE.MeshPhongMaterial({ color: ANATOMY_COLORS.joints });
                    const joint = new THREE.Mesh(jointGeometry, jointMaterial);
                    
                    joint.position.set(
                        startX, 
                        startY + ((i + 0.5) * segmentLength * 1.2), 
                        startZ
                    );
                    joint.name = `${name}_joint_${i}`;
                    fingerGroup.add(joint);
                }
            }

            return fingerGroup;
        }

        function setupCameraControls() {
            // Contr√¥les de cam√©ra simples avec souris
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };

                const deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        toRadians(deltaMove.y * 1),
                        toRadians(deltaMove.x * 1),
                        0,
                        'XYZ'
                    ));

                humanModel.quaternion.multiplyQuaternions(deltaRotationQuaternion, humanModel.quaternion);

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            function toRadians(angle) {
                return angle * (Math.PI / 180);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Mise √† jour des statistiques
            updatePerformanceStats();
            
            // Rendu
            renderer.render(scene, camera);
        }

        function updatePerformanceStats() {
            // Simuler les FPS (en r√©alit√©, ce serait plus complexe)
            const fps = Math.floor(60 + Math.random() * 5 - 2.5);
            document.getElementById('fps-counter').textContent = `${fps} FPS`;
            
            // Barre de performance
            const performanceFill = document.getElementById('performance-fill');
            performanceFill.style.width = `${Math.min(fps / 60 * 100, 100)}%`;
        }

        // === FONCTIONS DE GESTES ===

        function setLanguage(lang) {
            currentLanguage = lang;
            document.getElementById('current-language').textContent = lang;
            
            // Mettre √† jour les boutons
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            console.log(`üåç Langue chang√©e: ${lang}`);
        }

        function showLetter(letter) {
            console.log(`üî§ Affichage de la lettre: ${letter} (${currentLanguage})`);
            
            // Mise √† jour du statut
            document.getElementById('current-gesture').textContent = `Lettre ${letter}`;
            document.getElementById('gesture-description').innerHTML = `
                <p><strong>Lettre ${letter} (${currentLanguage})</strong></p>
                <p>Configuration manuelle pour la lettre ${letter} en ${currentLanguage}.</p>
            `;
            
            // Ici, impl√©menter les configurations sp√©cifiques pour chaque lettre
            applyLetterConfiguration(letter);
        }

        function showNumber(number) {
            console.log(`üî¢ Affichage du nombre: ${number} (${currentLanguage})`);
            
            document.getElementById('current-gesture').textContent = `Nombre ${number}`;
            document.getElementById('gesture-description').innerHTML = `
                <p><strong>Nombre ${number} (${currentLanguage})</strong></p>
                <p>Configuration manuelle pour le nombre ${number} en ${currentLanguage}.</p>
            `;
            
            applyNumberConfiguration(number);
        }

        function loadGesture(gestureName) {
            console.log(`ü§ü Chargement du geste: ${gestureName}`);
            currentGesture = gestureName;
            
            // R√©initialiser les positions
            resetArmPositions();
            
            // Appliquer le geste sp√©cifique
            switch(gestureName) {
                case 'hello':
                    applyHelloGesture();
                    updateGestureInfo('Bonjour', 'Salutation amicale avec mouvement de la main');
                    break;
                case 'please':
                    applyPleaseGesture();
                    updateGestureInfo('S\'il vous pla√Æt', 'Demande polie avec paumes ouvertes');
                    break;
                case 'thank-you':
                    applyThankYouGesture();
                    updateGestureInfo('Merci', 'Expression de gratitude');
                    break;
                case 'sorry':
                    applySorryGesture();
                    updateGestureInfo('D√©sol√©', 'Expression d\'excuse');
                    break;
                case 'yes':
                    applyYesGesture();
                    updateGestureInfo('Oui', 'Affirmation');
                    break;
                case 'no':
                    applyNoGesture();
                    updateGestureInfo('Non', 'N√©gation');
                    break;
                case 'love':
                    applyLoveGesture();
                    updateGestureInfo('Amour', 'Expression d\'affection');
                    break;
                case 'help':
                    applyHelpGesture();
                    updateGestureInfo('Aide', 'Demande d\'assistance');
                    break;
                default:
                    console.warn(`Geste inconnu: ${gestureName}`);
            }
            
            updateActiveJointsCounter();
        }

        function applyLetterConfiguration(letter) {
            // Configurations ASL/LSQ pour chaque lettre
            const letterConfigs = {
                'A': { rightHand: { fingers: 'fist', thumb: 'side' } },
                'B': { rightHand: { fingers: 'straight', thumb: 'across' } },
                'C': { rightHand: { shape: 'C' } },
                // ... autres lettres
            };
            
            // Appliquer la configuration si elle existe
            if (letterConfigs[letter]) {
                applyHandConfiguration('right', letterConfigs[letter].rightHand);
            }
        }

        function applyNumberConfiguration(number) {
            // Configurations pour les nombres
            const numberConfigs = {
                0: { rightHand: { shape: 'O' } },
                1: { rightHand: { fingers: 'index' } },
                2: { rightHand: { fingers: 'peace' } },
                3: { rightHand: { fingers: 'three' } },
                4: { rightHand: { fingers: 'four' } },
                5: { rightHand: { fingers: 'open' } },
                // ... autres nombres
            };
            
            if (numberConfigs[number]) {
                applyHandConfiguration('right', numberConfigs[number].rightHand);
            }
        }

        function resetArmPositions() {
            // R√©initialiser les bras √† la position neutre
            if (leftArm) {
                leftArm.rotation.set(0, 0, 0);
                leftArm.position.set(-0.5, 0, 0);
            }
            
            if (rightArm) {
                rightArm.rotation.set(0, 0, 0);
                rightArm.position.set(0.5, 0, 0);
            }
        }

        function applyHelloGesture() {
            // Lever la main droite et faire un mouvement de salutation
            if (rightArm) {
                rightArm.rotation.z = -Math.PI / 4; // Lever le bras
                
                // Trouver la main droite et la faire bouger
                const rightHand = rightArm.getObjectByName('rightHand');
                if (rightHand) {
                    rightHand.rotation.x = Math.PI / 6; // Incliner l√©g√®rement
                }
            }
        }

        function applyPleaseGesture() {
            // Mains ouvertes devant le corps
            if (leftArm && rightArm) {
                leftArm.rotation.z = Math.PI / 6;
                rightArm.rotation.z = -Math.PI / 6;
                leftArm.rotation.x = Math.PI / 4;
                rightArm.rotation.x = Math.PI / 4;
            }
        }

        function applyThankYouGesture() {
            // Main droite pr√®s du menton puis vers l'ext√©rieur
            if (rightArm) {
                rightArm.rotation.z = -Math.PI / 3;
                rightArm.rotation.x = Math.PI / 4;
                rightArm.position.set(0.3, 0.2, 0);
            }
        }

        function applySorryGesture() {
            // Poing ferm√© frottant sur la poitrine
            if (rightArm) {
                rightArm.rotation.z = -Math.PI / 6;
                rightArm.rotation.x = Math.PI / 3;
            }
        }

        function applyYesGesture() {
            // Poing qui bouge de haut en bas
            if (rightArm) {
                rightArm.rotation.z = -Math.PI / 4;
                rightArm.rotation.x = Math.PI / 6;
            }
        }

        function applyNoGesture() {
            // Index et majeur qui bougent ensemble
            if (rightArm) {
                rightArm.rotation.z = -Math.PI / 3;
                rightArm.rotation.y = Math.PI / 8;
            }
        }

        function applyLoveGesture() {
            // Signe "I love you" - pouce, index et auriculaire tendus
            if (rightArm) {
                rightArm.rotation.z = -Math.PI / 2;
                rightArm.position.set(0.5, 0.3, 0);
            }
        }

        function applyHelpGesture() {
            // Main gauche supporte le coude droit, main droite lev√©e
            if (leftArm && rightArm) {
                leftArm.rotation.z = Math.PI / 4;
                leftArm.rotation.x = Math.PI / 6;
                rightArm.rotation.z = -Math.PI / 2;
                rightArm.rotation.x = Math.PI / 8;
            }
        }

        function applyHandConfiguration(side, config) {
            // Appliquer une configuration sp√©cifique √† une main
            const arm = side === 'left' ? leftArm : rightArm;
            if (!arm) return;
            
            const hand = arm.getObjectByName(`${side}Hand`);
            if (!hand) return;
            
            // Ici, impl√©menter les configurations sp√©cifiques des doigts
            // bas√©es sur les positions ASL/LSQ r√©elles
        }

        function updateGestureInfo(title, description) {
            document.getElementById('current-gesture').textContent = title;
            document.getElementById('gesture-description').innerHTML = `
                <p><strong>${title}</strong></p>
                <p>${description}</p>
            `;
            
            // Mettre √† jour la lecture labiale si applicable
            document.getElementById('lip-reading-word').textContent = title;
        }

        function updateActiveJointsCounter() {
            // Compter les articulations actives
            let activeJoints = 0;
            const totalJoints = 27; // Total th√©orique pour les bras et mains
            
            humanModel.traverse((child) => {
                if (child.isMesh && (
                    child.name.includes('Shoulder') ||
                    child.name.includes('Elbow') ||
                    child.name.includes('Wrist') ||
                    child.name.includes('joint')
                )) {
                    const rotation = child.rotation;
                    if (Math.abs(rotation.x) > 0.01 || 
                        Math.abs(rotation.y) > 0.01 || 
                        Math.abs(rotation.z) > 0.01) {
                        activeJoints++;
                    }
                }
            });
            
            document.getElementById('active-joints').textContent = `${activeJoints}/${totalJoints}`;
        }

        // === FONCTIONS DE CONTR√îLE ===

        function updateRotation() {
            const rotationY = document.getElementById('rotation-y').value;
            if (humanModel) {
                humanModel.rotation.y = (rotationY * Math.PI) / 180;
            }
        }

        function updateZoom() {
            const zoomValue = document.getElementById('zoom').value;
            if (camera) {
                camera.position.z = 4 / zoomValue;
            }
        }

        function updateAnimationSpeed() {
            animationSpeed = document.getElementById('animation-speed').value;
            console.log(`‚ö° Vitesse d'animation: ${animationSpeed}x`);
        }

        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                const container = document.getElementById('viewer-3d');
                const rect = container.getBoundingClientRect();
                
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                renderer.setSize(rect.width, rect.height);
            }
        });

        console.log('üé≠ Syst√®me de langue des signes 3D charg√©');
    </script>
</body>
</html>
